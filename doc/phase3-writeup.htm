<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester (bdl20) </br >
Carmen Condeluci (crc73) </br >
Ryan Conley (rgc11) </br >

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In order to address the threats posed in the Threats T1-T4 our group used a 
wide variety of Cryptographic techniques. We use Symmetric key cryptography to 
stop passive eavesdroppers, public key cryptography for mutual authentication, 
digital signing for taken verification, and key exchange protocols such 
Diffie-Hellman to swap session keys. We also use Strong password protocols for a
proposed login method.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->
WE NEED A CRYPTOGRAPHICALY SECURE RNG

<p>Begin this section by describing threat T1. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s insecure
implementation.</p>

<p>
  Threat 1 (T1) is the threat of an Unauthorized Token Issuance. This threat can 
  be succinctly be described as the fact that user Alice cannot request (and then 
  obtain) a token meant for user Bob. It is easy to imagine this scenario being 
  exploited. Attacker Alice tells the Group server "Hi, I'm Bob." The group server 
  happily responds with the Token of user Bob. Now when Alice makes a request to 
  the file server she can access all the files that Bob is supposed to including 
  ones that she is not supposed to access. In our current insecure implementation 
  a user can set their username to what ever they and that is what is sent to the 
  Group server. Exploiting this is as simple as typing a name in a box. </br>
  <img src="images/FakeUser.png" alt="I am really User Alice"> 
  </br>In this case 
  Attacker Alice has entered User Bob's name in and will be requesting Bob's 
  Token instead of her own.
  <br><br>
  This threat is not a one time threat. The system must defend from attacker 
  Alice taking a Token bent for Bob after Bob has authenticated with the server 
  the initial time. This is the simple scenario of Alice waiting for the actual 
  User Bob to request a token and then Alice could copy the Token. This copy could 
  then be used on file servers to access Bob's files.
</p>

<p> We currently have two proposed solutions to solve this problem. The first is 
  a password protocol and the second is a public key cryptography solution.
</p>

<h3>Solution One: A password protocol.</h3>
<p>
  Our first solution is use passwords to protect the system from Unauthorized 
  Token Issuance. In this solution each user picks a password that must be 
  provided to the GroupServer upon login to authenticate that they are the user 
  they claim. The user and GroupServer will also exchange a shared key so that 
  Tokens issued later can be encrypted. This encryption will protect the Tokens 
  from being stolen later after the User Bob authenticates with the system. <br>
  The protocol would look like so: <br>
  <img src="images/password.png">
  <br>
  This protocol uses Diffie-Hellman to create a shared secret key, K, that is 
  computed by both Bob and the Server with the formula g<sup>bs</sup> mod q. b is 
  chosen by Bob with a cryptographically secure random number generator and s is 
  chosen by the server with a cryptographically secure random number generator too.
  Once
  this shared key is established the server still does not know if it is talking 
  to Bob so it needs to authenticate that it is. This is done with a password. 
  Using the shared key bob sends his username and password to the server. Once 
  the server receives the message and decrypts it with the key it will hash the
  password concatenated with a salt that is associated with the username. The 
  server then compares this &lt;username, hash&gt; pair with its database. If the
  entry exists then the server responses to Bob with his Token. This symmetric 
  key cryptography system would use AES with 128-bit keys. It would be set to any 
  mode besides ECB (which is vulnerable to replay attacks), we would use CBC. For 
  Hashing the password we would use SHA-1 because MD-5 is weak to some attacks. 
  The numbers b and s will be chosen with the java.security.SecureRandom library.
</p>
  This protocol sufficiently stops attacks of unauthorized Token assurance. The 
  user and the server use Diffie-Hellman to exchange secret keys. At this point 
  the communication between the two cannot be observed by a third party. Once this 
  secure communication channel has been set up the users password can be set to 
  the server. The server hashes this key and verifies that this user is the real 
  user. Assuming that this secret is known only by the user then this is 
  sufficient to prove that the user is authorized. The rest of the communication 
  that will occur between the user and the server will be encrypted by the shared 
  key K. Knowing K if proof that the user is the same user that authenticated 
  previously. The user and server are the only ones that know this key K and 
  therefore being able to encrypt and decrypt things with K means that the person 
  knows K.  
<p>

</p>
<h3>Solution Two: A public key cryptography protocol.</h3>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->
TIME STAMP
<p>Repeat the steps as for Threat T1.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>Repeat the steps as for Threat T1.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>Repeat the steps as for Threat T1.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

