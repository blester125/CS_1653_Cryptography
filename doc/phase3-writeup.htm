<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

img.image {
  display: block;
  margin-left: auto;
  margin-right: auto; }
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester (bdl20) </br >
Carmen Condeluci (crc73) </br >
Ryan Conley (rgc11) </br >

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In order to address the threats posed in the Threats T1-T4, our group used a 
wide variety of cryptographic techniques. We use symmetric key cryptography to 
stop passive eavesdroppers, public key cryptography for mutual authentication, 
digital signing for token verification, and key exchange protocols such as
Diffie-Hellman to swap session keys. All notation used in this write-up is derived from
the notation provided to us by Professor Garrison. A "g" represents the group
server, a "u" the user, and an "f" a file server.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Threat 1 (T1) is the threat of an Unauthorized Token Issuance. This threat can 
  succinctly be described as user Alice requesting (and then 
  obtaining) a token meant for user Bob. It is easy to imagine this scenario being 
  exploited. Attacker Alice tells the Group server that her username is Bob. The 
  group server responds with the token of user Bob. Now when Alice makes a
  request to the file server, she can access all the files that only Bob should be authorized to. 
  In our prior phase's insecure implementation, 
  a user can set their username to whatever they want and that is then sent to the 
  group server. Exploiting this was as simple as typing a name in a box. </br><br>
  <img src="images/FakeUser.png" title="I am really User Alice" class="image"> 
  </br>In this case, 
  attacker Alice has entered user Bob's name in the username field and will be 
  requesting Bob's token instead of her own. In our old implementation, the request for 
  a token simply takes a username and responds with that user's token. This means 
  that Alice using Bob's name will give her Bob's token.
  <br>
  This threat is not a one time threat. The system must defend from attacker 
  Alice taking a token meant for Bob after Bob has authenticated with the server 
  the initial time. This is the simple scenario of Alice waiting for the actual 
  user Bob to request a token, and then Alice could copy that token. This copy could 
  then be used on file servers to access Bob's files.
</p>

<p>
  Our solution is use passwords to protect the system from Unauthorized 
  Token Issuance. 
  <br><br>
  <!-- User Creation, Justify why ADMIN gives password to user, Describe the 
    implementation of the newuser flag-->
  In this solution, an ADMIN picks a password that must be 
  provided to the group server upon user creation. This initial password will be 
  given to the user by the ADMIN, by some means deemed secure by the ADMIN, such as
  in person.
  The group server will set a flag in the UserList that this user needs a new 
  password (a newPassword flag). This 
  will trigger a forced password change once the user logs on. Note: this does not 
  apply to the initial server ADMIN. Once the new password is established, the flag in unset
  and this newly created password is established as the user's password.
  <!-- Authentication Protocol 
    Key Exchange
    to Argue:
      Diffie Hellman
      Random number selection
      Symmetric encryption to use AES
  -->
  <br><br>
  Before the user actually authenticates with the server, the two must set up secure
  communication over an insecure channel. They do this using the Diffie-Hellman key exchange protocol to 
  create a shared secret key, <b>K</b>, that will be used for symmetric key 
  cryptography.
  This Diffie-Hellman protocol will use these values <b>g</b> = 2 and 
  <b>q</b>
   = 2^2048 - 2^1984 - 1 + 2^64 * { [2^1918 pi] + 124476 }. The <b>g</b> being a
   generator for <b>q</b>, where q is a large prime number, thus minimizing the probablility
   of a brute force attack succeeding.
  The numbers <b>b</b> and <b>s</b> will be selected at random by Bob and 
  the Server respectively 
  using the java.security.SecureRandom library. The secret key <b>K</b> is computed
   with
  <b>K</b> = g<sup>bs</sup> mod q. This symmetric key cryptography system would 
  use AES with 128-bit keys. AES would be used as a block cypher in CBC mode, 
  padded with the PKCS5 padding scheme. CBC 
  is used because ECB is vulnerable to replay attacks and the padding is used so that 
  entire blocks are encrypted/decrypted and no block is left sparse.
  This encryption will protect the tokens from being stolen later after the user 
  Bob authenticates with the system. In order to defend from replay attacks, a new 
  shared key <b>K</b> is created every time a user connects to the group server. 
  <br><br>
  <!--
    Password Authentication
    to Argue:
      Salt generation
      Hash Function
      Hashed password || Salt storage
  -->
  Once this shared key is established and therefore a secure communication channel 
  is setup, the server still needs to verify that the client is who they are claiming to be. 
  This is done with a password. Using the 
  shared key, Bob sends his username and password to the server. Once 
  the server receives the message and decrypts it with the shared key, it will hash the
  password concatenated with a salt that is associated with the username.
  The server then compares the &lt;username, hash&gt; pair with its database. Both 
  the salt and the hash of the password concatenated with the salt will be stored 
  in the User object associated with that user. The salt will be generated when 
  the password is changed. The salt will be generated randomly with the 
  java.security.SecureRandom library. The salt is 256 bits long. The hash will be computed using SHA-256 because
  recently SHA-1 has been showing the same weakness that MD-5 did before it was 
  broken. If the hash matches the saved hash then the server responds to Bob with 
  a success message. Later, Bob can request a token with a request that is 
  encrypted with <b>K</b>. 
  <br><br>The protocol would look like so: <br>
  <img src="images/password.png" class="image" title="password change">
  
  In the case where a user has the newPassword flag set, when the server authenticates their 
  password, the server will also include a "Change Password" message. When this 
  is received by the client, the client will prompt the user to select a new 
  password. Once this new password is chosen then it is encrypted with the shared key and sent back 
  to the server. The server decrypts this new password and will generate a new 
  salt with the same secure random number generator as before. The group server 
  concatenates the new password and the new salt and hashes it with SHA-256. Once 
  this new hash is saved, the newPassword flag is unset and the server tells the client 
  that the change was a success. Clients can also initiate this change password 
  protocol provided they are already authenticated by clicking the "change password"
  button on the GUI, thus initiating the process just described.
  <br><br>The new password protocol would look like this</br>
  <img src="images/newuser.png" class="image" title="new user">  
</p>
<p>
  <!-- Argument that this works
    Need to argue for
      Diffie-Hellman
      Password
      show it defending from replay attack
      The new user flag is not a problem.
  -->

  This protocol sufficiently stops attacks of unauthorized token issuance. The 
  user and the server use Diffie-Hellman to exchange shared secret keys. The key exchange 
  is secure because the user and the server generate a random <b>b</b> and a random <b>s</b>
  respectively. 
  These numbers however are only transmitted in the form of g<sup>[b|s]</sup>mod p 
  so an attacker who steals either or both of these then cannot recover 
  g<sup>bs</sup> mod q (K). As they would only be able to calculate g<sup>b+s</sup> mod q,
  and deriving b or s is then safe by the hardness of the discrete log problem.
  This means that <b>K</b> is a secret between the two parties.
  At this point the communication between the two cannot be observed by a third 
  party.
  <br><br>
  Only after this secure communication channel has been set up, the user's password can be 
  sent to the server. This password system is sufficient to authenticate a user 
  assuming that the user is the only person who knows their password. 
  The server concatenates the password with the saved salt 
  associated with the user. This result is then hashed using SHA-256. This hash is 
  compared to the hash associated with the user. If the hash of the password plus 
  salt matches the saved hash, then the user is authenticated. Matching the hashes 
  is sufficient to authenticate the user because SHA-256 is a cryptographically secure 
  hash. This means that SHA-256 has second preimage resistance. This means that it is 
  infeasible to find a second message y that hashes to the same value as the 
  original value x. This means that if the hashes match the user must know the 
  real password rather than generating a password that has a matching hash,
  in addition to having to not being able to precompute a password dictionary due
  to the salt, this is thus secure. 
  Using  a cryptographically secure hash also means that it has preimage resistance. This
  means that if the group server is ever compromised then it would be infeasible 
  for attackers to recover the original passwords from the stolen hashes.  
  <br><br>
  Once established, all communication that occurs between the user and the server 
  will be encrypted by the shared key <b>K</b>. Knowing <b>K</b> is proof that the user is the 
  same user that authenticated previously. The user and server are the only ones 
  that know this key <b>K</b> and therefore being able to encrypt and decrypt things 
  with <b>K</b> proves that user knows <b>K</b> and is therefore the same user. 
  <br><br>
  This system is safe from replay attacks. For example: if an attacker steals the 
  two messages that are starred... 
  <br><img src="images/passwordreplay.png" class="image" title="password replay"><br>
  Later, the attacker sends these two messages to 
  the server. This will not result in the attacker gaining access 
  to the system. The server will choose a different value of <b>s</b> than it chose when 
  the attacker recorded the messages. This means that the secret key <b>K</b> will be 
  different than the <b>K</b> that was chosen between Bob and the server. This means the server will not be able
  to decrypt the message from the attacker because the attacker is using the old 
  <b>K</b>, which is incorrect.
  <br><br>
  In this scenario, group servers are trusted which means that the newPassword flag 
  cannot be used to trigger a forced password reset by an attacker. Even if the 
  newPassword flag was somehow set it would not compromise the user account because 
  the user needs to authenticate with the server before changing the password.
  <br><br>
  It is assumed that if the ADMIN of the system chose our system, it is because 
  of the security that comes with it. Due to this assumption, it is reasonable to 
  assume that the ADMIN will have some method of getting the default password to 
  the user out-of-band (physical discussion, email, etc...). The main use of this 
  system will be in a work setting where the users and ADMIN are familiar with each other, such as 
  local work- or classroom-sized groups. These groups consist of users and 
  administrators that are all in close, physical proximity to one another, making this 
  out-of-band verification with a system administrator trivial for an ADMIN. It is  
  reasonable to assume that the ADMIN could see the user face-to-face in order to
  disclose the default password to them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Token modification or forgery is a problem in the system that must be addressed. 
  The first example of this would be users requesting a token from the server and 
  then adding groups to their token that they are not members of, which is possible in the previous
  implementation due to the tokens being stored in memory as plaintext, without any signature. This could allow 
  non-admin users to add themselves to the admin group and abuse those powers by accessing
  files they are not allowed to, creating users, and deleting users. The attacker/malicious user could also
  add themselves to any other group in the group server, gaining access to files they should
  not have access to, and being able to upload files to the group. 
  <br><br>Token modification/forgery:</br>
  <img src="images/insecure_token_modifcation_forgery.png" class="image" title="new user">  
  An abuse of this
  ability is flooding the group's files to make it difficult to locate the group's valid
  files, consuming the group's disk quota, impersonating other valid documents with false copies, or even stealing sensitive files.
  Another scenario would be that users or attackers create their own 
  tokens from scratch that grants them the same kind of 
  permissions as they acquired in the modification exploit. A final exploit in this 
  category would be saving a token that had access to a group g, then once the user
  was removed from group g for whatever reason, this saved token could be used to access group 
  g again taking advantage of the exploits outlined above. These threats can manifest themselves
  in the prior phase's implementation by having the user edit their token before sending it 
  to the file server. They could also save their tokens and reuse them at anytime, or simply fabricate new ones
  after obersving their structure. A token can be 
  forged by knowing the issuer (which is trivial to discover) the username of the user you wish
  to impersonate, and the names of the groups an attacker or malicious user may desire access to. All of this information
  is available. These modified, forged, or reused tokens can then be used with the file server.
</p>
<p>
  The first two problems of token modification and forgery are solved in the same way: digital signatures. 
  When a token is issued by the group server it will be hashed, and this hash 
  will be signed with the group server's private RSA key. The token is 
  hashed because of the variable length of tokens,
  which may be quite large due to variance in the size of the strings of the issuer, 
  username, and group names, and the number of groups, so this is hashed so as to normalize
  the length for use with RSA encryption. In order for all of this to occur
  there must be an agreeed upon serialization of the token between the group server and the file server
  so that when the group server hashes the token and signs the hash, the file server is
  able to hash the token in the same manner and compare its own hash with the 
  decrypted hash of the group server. There also must be an agreed upon hashing algorithm
  between the group server and the file server so that the hash will be created symmetrically. 
  For our implementation we will be using the SHA-2 with a 256 bit digest (SHA-256),
  which is, at the present moment, known to be secure and is forecasted to continue to be for
  the near future (more than a couple of years). The serialization of the
  token will occur by concatenating the 
  issuer, followed by the user, followed by all of the groups the user belongs to.
  It will appear as follows: issuer || user || groups with each section separated with the "#" sign. 
  The "#" symbol cannot be used as a character for any of the fields in the token and is enforced as such.
  The reason for this delimeter is so information cannot be injected into the token, such as a 
  malicious user adding group names into their username, causing hash collions. Take for example
  this simplified scheme where Token = USER || GROUPS: 'Bob' || 'ADMIN' then will be equal to 'BOBADMIN' || '' by its hash.
  The authentication message the user sends to the file server along with its group token will
  be the token itself accompanied with the signed hash of the token, and this message encrypted
  with the symmetric key generated from the user-file server Diffie-Hellmann exchange.
  Once the client passes this token along with the signed token to the 
  file server, the file server can verify it with the server's public key. 
  A file server will have knowledge of the group server's
  public RSA key upon the file server's creation, to be entered by the user who creates the file server.
  This is reasonable as by the nature of the key being public, there does not need to exist
  any security in the distribution of this public key, save for verifying the identity to whom it is associated. This is reasonable in our
  scenario to expect users who wish to create a new file server to have knowledge of the group server's
  public key because there is only one group server in the system and the user who is the 
  creator of the file server should be able to provide the public key
  by way of a trusted admin who has this knowledge of the system. The public
  key can then be transmitted to the user either in person, operating then in 
  the same channel by which a user may authenticate a file server's public key.
  The third issue mentioned of reusing an old token can 
  be solved with timestamps. This achieves freshness for a token and mitigates the threat of
  a replay attack of the token in the same session by only allowing a token to be used within a small
  and reasonable frame of time for it to be transmitted securely over the network,
  on the order of a couple of seconds (10 seconds in our implementation, derived
  by pinging locations on the opposite side of the world and setting a bound slightly above the slowest times). 
  The time the token was issued will be added as a new field in the Token object.
  This changes the aforementioned serialization
  by adding in the concatenation of the timestamp, which will also be used in the signed hash
  the group server creates, and so the agreed upon scheme between the group server and file server
  must be modified to account for this measure. It will be modified by appending
  the previous token scheme to the timestamp. So the serialization and subsequent transmission
  to the user to be used with the file server within the time frame will appear as follows:
   { token || [token]K<sub>g</sub><sup>-1</sup> }K<sub>uf</sub>
   Where the token = timestamp || issuer || subject || groups with each section separated with the "#" sign,
   as well as each group being delimited too.
   The signed hash is saved as a field in the token. The "#" is prohibited from being used in any of these sections.
  If the file server receives a token where 
  the timestamp is outside of the time frame given the current time, then the file server will know 
  the token has been tampered with or that the received token is an expired token
  attempting to be reused, and in both cases, the token is discarded by the file server
  and the user attempting the connection/request is refused. By including the timestamp in the signed hash,
  it guarantees the token cannot be tampered with without the file server being able
  to verify its modification.
  <br><br>An example of how this verification works:
  <img src="images/TokenVerification.png" class="image" title="token verification">
</p>
<p>
  Assuming that the group server is the only one with its private key then we know 
  that a hashed token signed from the server only could have been issued by the group server. Even if a middle party decrypts 
  the token with the server's public key and alters the token they will not be 
  able to sign it properly because they do not have the private key of the server. The timestamp 
  solution ensures that old tokens are not passed off as legitimate at a later time by checking
  that the token is received by the file server within the time frame (presently set to 10 seconds).
  It is also then known that this timestamp has not been altered due to it being incorporated in the signed hash
  of the entire authentication request. There are problems with the timestamp approach like if the attacker attacks the 
  NTP and is able to change the time for the file server to be within the time frame for
  which the token will be valid, allowing a token to be resused in a replay attack.
  An attacker this motived is able to bypass the described system,
  so we rely on the assumption that the NTP and its connection to the file server is secure, and
  this assumption can safely be trusted to hold true for this phase.
  Another concern is being certain that the group server and the file servers are in-sync, 
  but the integrity of this is trusted to be maintained by the NTP, with all timestamps being UTC,
  thus keeping any difference in times that may arise to be within a small and acceptable margin of error. 
  Lastly, a man in the middle attacker who operates quick enough to pass along the authentication request
  to the file server so as to be within the allowed time frame would be able to compromise
  the system, this also proves problematic in that the time frame cannot be made so short
  that requests to the file server are thrown away when they are valid, but not so large
  as to be able to be replayed. This is prevented by all communication between a client
  and a server being encrypted with the generated symmetric key. Now, if an attacker
  were to obtain an encrypted token, it would be worthless as the new connection via file server
  would be using a different shared symmetric key. So we rely on the hardness of the discrete logarithm problem
  to keep the communication between server and user secure, and the timestamp so expired tokens
  cannot be reused. It is only an attacker who violates our assumptions that the symmetric
  key K is secure and/or that the NTP is secure for the servers that could pose a threat to token
  verification/forgery.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  An unauthorized file server is a large problem that this system faces. For example, a user
  tries to connect to server s and instead connects to server s'. If the server s' 
  is unauthorized, it probably will not be trusted like a file server would be to 
  behave correctly. This means that an untrusted file server could accept sensitive 
  files for upload, but then freely give these files to anyone that asks for them
  or even distribute them on the web. Or, conversely, provide false files
  when receiving download requests.
  After authenticating a file server, there needs to be a way to make sure that you 
  are still communicating with the same server that you authenticated with.
</p>
<p>
  This problem can be solved in the same way that SSH servers are authenticated. 
  The client program will cache the keys of servers that it has connected to in 
  the past. If the server's key is not cached, a message displaying the key will be 
  shown to the user. It is then the users responsibility to check that the server
  they are connected to is really the server with said key.<br><br>
  <img src="images/sshwarning.png" class="image" title="ssh warning">
  <br>
  Messages to the file server will be encrypted with the shared symmetric key (which
  is much faster than RSA, a major concern when sending large amounts of data
  like that contained in files for downloading and uploading)
  and authentication will be done by utilizing RSA to encrypt a challenge/nonce.
</p>
<p>
  Before any sort of authentication with the file server takes place, Bob and 
  the file server must first set up a secure communication over an insecure channel.
  This is accomplished using the Diffie-Hellman protocol to create a shared session key,
  <b>K</b>, that will be used for the remainder of their session for symmetric key cryptography.
  This Diffie-Hellman protocol will use the values <b>g</b> = 2 and <b>q</b> = 
  2^2048 - 2^1984 - 1 + 2^64 * { [2^1918 pi] + 124476 }, with the values of <b>b</b> and <b>s</b> being generated at random with the
  java.security.SecureRandom library by Bob and the file server, respectively. 
  Just like in our password authentication solution above, the secret session key 
  <b>K</b> will be computed with <b>K</b> = g<sup>bs</sup> mod q. We will employ AES 
  with 128-bit keys for our symmetric key cryptography system for this session key.
  Again, AES would be used as a block cipher in CBC mode, as ECB is vulnerable to 
  replay attacks. This per-session encryption will prevent a rogue file server from 
  hijacking the connection after the file server has already been authenticated. 
  By generating a new, unique session key <b>K</b> each time a user connects to a file 
  server, replay attacks are also defended against.
</p>
<p>
  After this secure communication channel is established with its session key, 
  Bob needs to verify that the file server he is connecting to is indeed 
  the file server it claims to be. This can be accomplished with public key 
  cryptography via RSA with 2048-bit keys, as 1024-bit RSA keys were recently proven 
  by the NSA to be insecure. The file server first sends Bob its public RSA key, 
  <b>K<sub>s</sub></b>, encrypted with the session key, <b>K</b>. Upon receiving 
  this message, Bob decrypts <b>K<sub>s</sub></b> and then checks his cached table 
  of &lt;hostname:port, public_key&gt; pairs for a match. 

  <br><br>

  If a match is found, Bob sends a message to the file server containing a challenge, 
  <b>R1</b>, encrypted with the file server's public key, <b>K<sub>s</sub></b>. This 
  is then further encrypted with the session key, <b>K</b>. The file server then 
  decrypts this message using the session key then its private RSA key, then 
  sends back to Bob the challenge <b>R1</b> encrypted with the session key. If the 
  challenge was successfully decrypted by the file server, Bob can be certain that 
  the file server is legitimate and sends a message of success to the file server. 
  From this point, all communication between Bob and the file server is secured using 
  the session key until the connection is terminated.

  <br><br>
  The interactions between Bob and the file server are visually represented as follows:
  <br><br>

   <img src="images/matchfound.png" class="image" title="match found">

  <br><br>

  If a match is NOT found, Bob will view a message with information regarding the 
  file server he is attempting to authenticate, which would include the following: 

  <ul>
    <li>File Server Hostname</li>
    <li>Recieved RSA Public Key</li>
    <li>Cached RSA Public Key (if available)</li>
    <li>Warnings and Directives</li>
    <li>Options to Connect or Abort</li>
  </ul>

  If a pair exists in Bob's cache that includes a matching file server Hostname, 
  but a mismatched public RSA key, it can be concluded that the file server is 
  more than likely illegitimate (or has updated its key, in which case, this must
  be verified with an admin physically) and the connection should be aborted. If a pair does 
  NOT exist with any matches, this is the first connection of Bob to that particular 
  file server, and the file server requires physical verification by Bob to continue 
  the connection process. However, if Bob selects to abort the connection to the file 
  server, the session is terminated and the connection is dropped.

  <br><br>
  Both of these cases can be represented by the following diagram:
  <br><br>

   <img src="images/mismatch.png" class="image" title="mismatch">

  <br><br>

  If Bob selects to continue the connection process, he 
  will send a message to the file server containing a challenge, 
  <b>R1</b>, encrypted with the file server's public key, <b>K<sub>s</sub></b>. This 
  is then further encrypted with the session key, <b>K</b>. The file server then 
  decrypts this message using both the session key then its private RSA key, then 
  sends back to Bob the challenge <b>R1</b> encrypted with the session key. If the 
  challenge was successfully decrypted by the file server, the file server 
  is authenticated and Bob sends a message of success to the file server. Bob also 
  adds a new pair to his cached table of &lt;hostname:port, public_key&gt; 
  to reflect the new verified server. Bob and the file server are then free to 
  communicate using their session key until the connection is terminated.

  <br><br>
  This case is represented by the following diagram:
  <br><br>

   <img src="images/physicalverify.png" class="image" title="physically verify">

  <br><br>

  <p>
  This solution works because the users will physically verify the servers. This
  is similar to the way servers authenticate SSH and that method is 
  "tried and true". To ensure that we are talking to the same server we authenticated 
  with, we have used RSA public key cryptography in tandem with symmetric key 
  cryptography (created via a Diffie-Hellman exchange). Assuming that the server is 
  the only other party with the DH-generated session key, then our 
  encrypted messages will only be decrypt-able by the server we authenticated with, 
  ensuring we are always talking to <b>s</b> and not <b>s'</b>. Both during and after 
  the authentication process, we can ensure safe communication between the user and the 
  file server with the Diffie-Hellman protocol, as it is presumed safe by difficulty of the discrete 
  logarithm problem. Since we later issue a challenge to the server involving decryption
  with the server's private key, we need not sign our exchange process. Even if a man-in-the-middle 
  attack were to occur in an attempt to hijack the session, the adversary would not be able to 
  reproduce the server's actual private key, and the user would be alerted to the fact that 
  they are attempting to connect to an untrusted file server.
  </p>
  <p>
  Although it would be preferred to not require users to keep cached 
  tables of &lt;hostname:port, public key&gt; and perform physical verification, 
  it is justified within this context due to our system's infrastucture. 
  As group servers cannot be expected to have any information 
  about the (possible) multitude of file servers, and the fact that any user can run a 
  file server, a solution that only involves communication between the user and the file 
  server itself is required. When the user receives a mismatched public RSA key when they 
  already have a previous record of that file server's correct key, they are immediately 
  alerted to their attempt to connect to an <b>s'</b> file server. When this occurs, the server 
  the user is attempting to connect to is one of the following:

    <ul>
      <li>A brand new file server being connected to 
                                  for the first time (no match found in user cache)</li>
      <li>An old server with modified information (mismatch in user cache)</li>
      <li>An adversary attempting to pass off their own file server 
                                  as a known one (mismatch in user cache)</li>
    </ul>

  In all these situations, the user is then required to make contact with the system administrator
  out-of-band (physical discussion, email, etc...) to ensure that the information regarding the 
  file server's information is correct, and that it is in fact a verified part of the system. 
  This is only acceptable based on assumptions on how the entirety of our file-sharing system 
  will be utilized by consumers. Those who elect to utilize our system are likely choosing so 
  because they care immensely about the security of their sharing, therefore administrators will 
  be more than willing to hold information about valid file servers and respond to user inquiry 
  regarding file server validity. Furthermore, the scenarios in which our system will likely be 
  employed will be small, local work- or classroom-sized groups, consisting of users and 
  administrators that are all in close, physical proximity to one another, making this 
  out-of-band verification with a system administrator trivial for a user.
  </p>

</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  Information leakage via passive monitoring is a threat whose counter-measures
  have already been partially addressed through the satisfaction of the other threats
  by way of symmetric key cryptography using keys generated in an insecure, public channel via the 
  Diffie-Hellman protocol. 
  This threat can be thought of as two people talking in a room
  and there being a third person in the room who is listening to their 
  conversation. In the context of our program this means that people could listen 
  to and record the messages being relayed between the client and the server.
  With no measures taken to prevent this, it leaves the file sharing system vulnerable
  to such an attacker who may exploit it by stealing tokens or the contents and data being transmitted.
  With stolen tokens in our previously insecure implementation, an attacker could receive unauthorized information from the file server.
  By stealing tokens, it is reasonable to assume they could then modify these
  stolen tokens to suit whatever purposes they wish, relating back to threat 2. Another threat is that a file 
  may be stolen during a download or upload operation, exposing sensitive content
  to an attacker, nosy admin, etc. Only the server and the authorized requesting user should have access
  to this information, as it is assumed in the threat model that an administrator's
  only functions is to monitor and maintain the file sharing system itself,
  not the contents therein, and so they too should be excluded from this communication channel.
  A more generalized vulnerability information leakage poses is that any information leaked to attackers
  can provide information about the system's implementation that may aide in some other attack.
<p>
  Just how this problem can be framed in a real world scenario the 
  solution can be found in the same way. In the real life example of an 
  eavesdropper the two people talking would use another language that the 
  eavesdropper doesn't know, though this is where the metaphor becomes strained, for
  it is equivalent to the speaking in an entirely new language each session. 
  In a similar way the client and the servers will speak 
  their own language using encryption. At the beginning of all communication 
  between the client and one of the servers they will use the Diffie-Hellman 
  protocol to create a shared symmetric key <b>K</b>. They will then use this 
  key <b>K</b> in a symmetric 
  key cryptography system using AES with 128-bit keys, which is found to be secure at the present time. 
  It would be sufficient to set to be set any mode besides ECB (which is vulnerable to replay attacks, especially
  for larger amount of non-random data), and we will use CBC.
  These keys are generated for each interaction between a server and a client.
  This means that the client, the group server, and the
  file servers must all keep track of their symmetric keys and their respective
  correspondents, and these keys are discarded and never used again after 
  disconnection.
  We must then establish the values g, the shared root to be raised to a randomly generated value
  and p, the value by which this exponentiation is moduloed by.
  The value g is chosen to be a prime number that is a primitive root of p, in other words,
  g is a generator of the multiplicative group of integers modulo p, so more generally
  this means that g can produce all p-1 values depending on the exponent it is raised to. This is done to minimize
  the likelihood of guessing the power g was raised to modulo p. The value p is chosen to be
  a large prime number that is slightly less than a power of 2. This is mainly used
  for encrypted key exchange protocols, where the number g<sup>randomly chosen number</sup> mod p is
  encrypted using a weak secret, making an attacker unable to throw out most of the guessed
  weak secrets to decrypt the value g<sup>randomly chosen number</sup> mod p. Our chosen
  value p here will be chosen to satisfy this property in order to allow for the system
  to remain extensible in the event that such changes may be chosen to be implemented.
  The encryption scheme we are using is AES CBC, because it is in CBC mode we need to 
  send an initialization vector (IV) with it, which does not need to be secret, only random
  to ensure a randomized encryption every time. We use Envelopes in Envelopes to 
  solve this problem. Our encryption functions create javax.crypto.SealedObjects
  so we would encrypt an Envelope using one IV and then place that SealedObject 
  and the IV into another Envelope that is then sent.  
</p>
<p>
  This protocol will stop eavesdroppers. At each exchange the user and the server 
  generate a <b>b</b> and an <b>s</b> respectively. These numbers however are
  only transmitted 
  in the form of g<sup>[b|s]</sup>mod p so an attacker who steals either or both 
  of these then cannot recover g<sup>bs</sup> mod p (K), but the user and the server
  can generate g<sup>bs</sup> mod p by exponentiation of the received value 
  with their own randomly
  chosen exponent, thus guaranteeing correctness. This protocol relies on the assumption
  that both the server and the user will be able to keep their respective values of
  b and s secret in order for it to be secure, as having one exposed could compromise the key for that session,
  so long as the prior transmissions of g<sup>[b|s]</sup>mod p were saved or the attack was carried out actively somehow.
  This means that <b>K</b> is a secret between the two parties and therefore if used for encryption then the 
  third party will not be able to decrypt it when operating under these assumptions. 
  Creating a new key <b>K</b> for each session means that the encryption will be different 
  every time, so patterns cannot be used to guess at the content of the messages and
  if a session key <b>K</b> is compromised, it can only be used to decrypt the messages
  exchanged during that session.
  Sending the IV and SealedObject (encrypted Envelope) in a unencrypted Envelope is
  safe because the IV need only be random not secret. In fact it could not be secret 
  because the receiving party needs it to decrypt the SealedObject. This is safe 
  from eavesdroppers however because the secret key <b>K</b> is also needed to 
  decrypt the SealedObject and read its contents. 
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->
<p>
The first branching of possibilities we experience was for log-in authentication.
We weighed the pros and cons of password authentication versus RSA public-private key authentication.
The advantage of RSA being, under the assumption that users are not to be trusted,
most especially in giving them the freedom to create their own passwords, that RSA
forces them to use a cryptographically secure authentication protocol. However, it is the
keyword forced which made a counter-point for password log-in. Psychological acceptability
is a major concern when designing a system. We do not want our security to overshadow
the actual functionality of the deployed system, and username/password log-in is
common, and something the majority of users are comfortable with. We decided to do both,
as it did not require a drastic increase to a work-load especially given one will
already be completed. Password authentication was prioritized ultimately over RSA
for ease-of-use, and with the fact that these users who are operating in a file-system
emphasized for its security, to perhaps have some idea of creating acceptable password.
This, and with the frequent interaction with the administrators who are assumed to be
knowledgable in the system's security, it ultimately was chosen as the primary authentication
over RSA (even though we have both). The choice satisfies many of the pros of each.
</p>
<p>
There were a multitude of "gotcha's" that were discovered throughout the development phase.
One underestimate of ours about how malicious a user may be was the injection attack
where a field may be purposefully constructed so as to hash to a desired token. 
It was helpful to keep in mind that threats were equally present, both internally and externally of the system.
Another difficulty was establishing freshness for the tokens with our timestamp scheme.
There is no "right" value, though you can certainly formulate an intelligent guess, there
is always some trade-off between false-positives and false-negatives, and which we would choose to prioritize.
Under the assumptions of the system being deployed in a largely local setting, false-positives (an attacker
replaying old tokens) is less favorable, so the time frame was skewed in this manner.
There were other gotcha's from our security implementation which even affected our
client-side application in unexpected ways. To borrow once more from timestamps and freshness,
whenever a client needs to make a request to the file server, they must retrieve a fresh
token from the group server. In our GUI, this retrieval for some of the operations was done in
a step before the actual request to the file server was going to be made, causing freshness failures 
on the file server's side. For instance, a user clicks upload file, receives a token from the group server,
and then they input the file they wish to upload and make the request to the file server, where
the time it takes to actually input a file for upload will cause the token to expire.
</p>
<p>
From the outset, we knew obscure and unexpected difficulties like this would arise, so we
were as proactive as possible in outlining our threats, policy, and mechanism before even starting the implementation.
About half of our time was used in this way preparing ourselves for the implementation, as 
trying to fix an ever-growing amount of unexpected while developing this phase would have
been slower, uglier, and probably weaker overall from a security stand-point, so we made
an attempt at rigorously defining these aspects of the system before implementation. Even the threats and policy,
while partially outlined in the rubric from a very broad perspective, were not yet sufficient
for us to continue into the coding. Multiple verifications with our Professor were done,
and carrying on this sense of explicit outline, we arrived at a clear destination and path to that destination
for how we wanted the system by the end of this phase. The write-up and our diagrams were mostly completed and correct
before any coding was carried out. The interplay in our final proposed mechanisms we deem as secure with the given assumptions.
As going through the flow, we see a user must first authenticate with the group server securely over an insecure public channel,
receive a correct token upon authentication, that must be used with immediacy with an authenticated file server (done
securely by being in person with an admin) and all of the checks of the prior phase have been unaffected and are correct,
such as you must belong to that group to upload files, only an owner of the group can delete the group, etc. All of this comes together
to form a cohesive system. We finished in a timely manner and tested on the environment specified (machines in 6110 using linux) as
well as with our own machines. Testing uncovered a few more "gotcha's" that we were able to deal with, and we arrived at
both a system that is satisfactory and secure under the given assumptions, using a cohesive, clean,
and largely symmetric/simple protocols for like operations, and one that exceeds the requirements provided
in multiple-allowed forms of authentication (password and RSA).
</p>
<p>Below is a diagram of the full suite in action. In order to make use that 
  servers continue to talk to the same user that they authenticated they encrypt 
  communication with symmetric session keys. This authentication protocol ends 
  up covering threat 4 passive monitoring because all communication is encrypted 
  with a key that is not known by a third party.
<br><br>
<img src="images/full.png" class="image">
<br><br>
General cryptographic best practices we used were generating random numbers with
java.security.SecureRandom instead of java.util.Random. In this same vein all 
times that byte arrays are compared MessageDigest.isEqual is used rather than 
Arrays.equals to protect against timing attacks.
</p>

<h3>Extra Credit: A public key cryptography authentication protocol.</h3>
<p>
  A system that uses public key cryptography to protect the system from Unauthorized 
  Token Issuance and allows user to login with a RSA Public Key/Private Key pair.
  This system allows for a user to use public key cryptography to log into the 
  system rather than a username and password pair.
  <br><br>
  In this solution the user's public key is submitted
  to the GroupServer upon the creation of the user account or at the request of 
  an authenticated client. The user and server 
  create a shared secret <b>K</b> using a signed Diffie-Hellman protocol. This method 
  creates a shared <b>K</b> and authenticates the user and server with each other. <br><br>
  The protocol would look like so: <br>
  <img src="images/publicauth.png" class="image">
  <br> 
  <!--
	Once we pick g and q we need to test if g^b mod q will be to big for RSA and 
	if it is rewrite this section to use only the hash versions
  -->
  This protocol uses Diffie-Hellman to create a shared secret key, <b>K</b>, that 
  will be used for symmetric key cryptography. This Diffie-Hellman protocol will 
  use these values <b>g</b> = 2 and <b>q</b> = 2^2048 - 2^1984 - 1 + 2^64 * { [2^1918 pi] + 124476 }. The numbers <b>b</b> 
  and <b>s</b> will be selected at random by Bob and the Server respectively 
  using the java.security.SecureRandom library. The secret key <b>K</b> is computed
  with <b>K</b> = g<sup>bs</sup> mod q. This symmetric key cryptography system would 
  use AES with 128-bit keys. AES would be used as a block cypher in CBC mode. CBC 
  is used because ECB is vulnerable to replay attacks. This encryption will protect 
  the Tokens from being stolen later after the User Bob authenticates with the system. 
  In order to defend from replay attacks a new shared key <b>K</b> is created every 
  time a user connects to the Group Server. While this symmetric key is being 
  generated both the user and the server are also authenticating with each other 
  because signed Diffie-Hellman is being used. The user will send g<sup>b</sup> mod q 
  twice in the message, once in plaintext and once once signed with the users private
  key K<sub>b</sub><sup>-1</sup>. If g<sup>b</sup> mod q is too big for RSA then we
  will hash it with SHA-256 and sign the result. The server 
  will decrypt it with the users public key which would be saved in the User object 
  in the UserList and compare the plaintext version with the decrypted version (or 
  it will hash the plaintext with SHA-256 and compare it to the decrypted result if 
  it proves too large for RSA). If they match this means that the user is who they 
  say they are. The server will response by sending g<sup>s</sup> mod q twice. Once 
  in plaintext and once signed with the servers private key K<sub>s</sub><sup>-1</sup>.
  It will compute the hash with SHA-256 and sign that is stead if g<sup>s</sup> mod q 
  proves to big for RSA. The user will decrypt g<sup>s</sup> mod q
  with the servers public key. If the plaintext g<sup>s</sup> mod q matches the 
  decrypted one then the server is who they say they are and each party has 
  authenticated themselves to the other. Finally a fixed String like "Success" will 
  be sent from the user to the server encrypted with the shared secret key <b>K</b>
  so that the server knows that the user authenticated it and successfully computed 
  the symmetric key. The digital signatures 
  will be done with 2048 bit key RSA because the NSA recently published about a 
  break in 1024 as discussed in class. 
</p>
<p>
  This protocol sufficiently stops attacks of unauthorized Token issuance. The 
  user and the server use Diffie-Hellman to exchange secret keys. The key exchange 
  is secure because the user and the server generate a <b>b</b> and a <b>s</b>
  respectively. 
  These numbers however are only transmitted in the form of g<sup>[b|s]</sup>mod q 
  so an attacker who steals either or both of these then cannot recover 
  g<sup>bs</sup> mod q (K). This means that K is a secret between the two parties.
  At this point the communication between the two cannot be observed by a third 
  party. Diffie-Hellman is safe to use because figuring out g<sup>bs</sup> mod p 
  from either message is the discrete log problem which is presumed to be hard.
  At this point 
  the communication between the two cannot be observed by a third party because it 
  is encrypted with <b>K</b>. 
  <br>Assuming 
  that each the user and the server are the only ones that know their own private 
  keys then the ability to encrypt a message that can be decrypted with the senders 
  public keys means that the sender is the real person. The rest of the communication 
  that will occur between the user and the server will be encrypted by the shared 
  key <b>K</b>. Knowing <b>K</b> if proof that the user is the same user that authenticated 
  previously. The user and server are the only ones that know this key <b>K</b>
  and 
  therefore being able to encrypt and decrypt things with <b>K</b> means that the 
  person knows <b>K</b>. 
</p>
<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

