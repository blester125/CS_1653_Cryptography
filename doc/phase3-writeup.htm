<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

img.image {
  display: block;
  margin-left: auto;
  margin-right: auto; }
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester (bdl20) </br >
Carmen Condeluci (crc73) </br >
Ryan Conley (rgc11) </br >

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In order to address the threats posed in the Threats T1-T4 our group used a 
wide variety of Cryptographic techniques. We use Symmetric key cryptography to 
stop passive eavesdroppers, public key cryptography for mutual authentication, 
digital signing for token verification, and key exchange protocols such 
Diffie-Hellman to swap session keys. We also use Strong password protocols for a
proposed login method.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Threat 1 (T1) is the threat of an Unauthorized Token Issuance. This threat can 
  be succinctly be described as user Alice requesting (and then 
  obtaining) a token meant for user Bob. It is easy to imagine this scenario being 
  exploited. Attacker Alice tells the Group server that her username is Bob. The 
  group server happily responds with the Token of user Bob. Now when Alice makes a
  request to the file server she can access all the files that Bob is supposed to 
  including 
  ones that she is not supposed to access. In our current insecure implementation 
  a user can set their username to whatever they want and that is what is sent to the 
  group server. Exploiting this is as simple as typing a name in a box. </br></br>
  <img src="images/FakeUser.png" title="I am really User Alice" class="image"> 
  </br>In this case, 
  Attacker Alice has entered User Bob's name in the username field and will be 
  requesting Bob's token instead of her own. In our implementation, the request for 
  a Token simply takes a user name and responds with that user's Token. This means 
  that Alice using Bob's name will give her Bob's Token.
  <br><br>
  This threat is not a one time threat. The system must defend from attacker 
  Alice taking a token meant for Bob after Bob has authenticated with the server 
  the initial time. This is the simple scenario of Alice waiting for the actual 
  user Bob to request a token and then Alice could copy the token. This copy could 
  then be used on file servers to access Bob's files.
</p>

<p>
  Our solution is use passwords to protect the system from Unauthorized 
  Token Issuance. 
  <br><br>
  <!-- User Creation, Justify why ADMIN gives password to user, Describe the 
    implementation of the newuser flag-->
  In this solution, an ADMIN selects a password that must be 
  provided to the GroupServer upon user creation. This initial password will be 
  given to the user by the ADMIN. 
  The GroupServer will set a flag in the UserList that this user is new (a newuser 
  flag). This 
  will trigger a forced password change once the user logs on. 
  <!-- Authentication Protocol 
    Key Exchange
    to Argue:
      Diffie Hellman
      Random number selection
      Symmetric encryption to use AES
  -->
  <br><br>
  Before the user actually authenticates with the server, the two must set up secure
  communication over an insecure channel. They do this using Diffie-Hellman to 
  create a shared secret key, K, that will be used for symmetric key cryptography.
  This Diffie-Hellman protocol will use these values p = NUMBER and q = NUMBER.
  The numbers b and s will be selected at random by Bob and the Server respectively 
  using the java.security.SecureRandom library. The secret key K is computed with
  K = g<sup>bs</sup> mod q. This symmetric key cryptography system would 
  use AES with 128-bit keys. AES would be used as a block cypher in CBC mode. CBC 
  is used because ECB is vulnerable to replay attacks.
  This encryption will protect the Tokens from being stolen later after the User 
  Bob authenticates with the system. In order to defend from replay attacks a new 
  shared key K is created every time a user connects to the Group Server. 
  <br><br>
  <!--
    Password Authentication
    to Argue:
      Salt generation
      Hash Function
      Hashed password || Salt storage
  -->
  Once this shared Key is established and therefore a secure communication channel 
  is setup, the server still needs to verify that the client it is talking to, who 
  is claiming to be Bob, is really Bob. This is done with a password. Using the 
  shared key Bob sends his username and password to the server. Once 
  the server receives the message and decrypts it with the key, it will hash the
  password concatenated with a salt that is associated with the username. The 
  server then compares this &lt;username, hash&gt; pair with its database. Both 
  the salt and the hash of the password concatenated with the salt will be stored 
  in the User object associated with that user. The salt will be generated when 
  the saved password is changed. The salt will be generated randomly with the 
  java.security.SecureRandom library. The Hash will be computed using SHA-2 because
  recently SHA-1 has been showing the same weakness that MD-5 did before it was 
  broken. If the hash matches the saved hash, then the server responds to Bob with 
  his Token.
  <br><br>The protocol would look like so: <br>
  <img src="images/password.png" class="image">
  <br>
  When a user has a new user flag set, then when the Server authenticates their 
  password it will also include a "Change Password" message. When this 
  is received by the client, the client will prompt the user to select a new 
  password. Once this new password is chosen then it is encrypted and sent back 
  to the server. The server decrypts this new password and will generate a new 
  salt with the same secure random number generate as before. The Server 
  concatenates the new password and the new salt and hashes it with SHA-2. Once 
  this new hash is saved, the newuser flag is unset and the server tells the client 
  that the change was a success.
  <br><br>The new user protocol would look like this:</br>
  <img src="images/newuser.png" class="image">  
</p>
<p>
  <!-- Argument that this works
    Need to argue for
      Diffie-Hellman
      Password
      show it defending from replay attack
      The new user flag is not a problem.
  -->

  This protocol sufficiently stops attacks of unauthorized Token issuance. The 
  user and the server use Diffie-Hellman to exchange secret keys. The key exchange 
  is secure because the user and the server generate a b and a s respectively. 
  These numbers however are only transmitted in the form of g<sup>[b|s]</sup>mod q 
  so an attacker who steals either or both of these then cannot recover 
  g<sup>bs</sup> mod q (K). This means that K is a secret between the two parties.
  At this point the communication between the two cannot be observed by a third 
  party. 
  <br><br>
  Once this secure communication channel has been set up, the user's password can be 
  sent to the server. This password system is sufficient to authenticate a user 
  assuming that the user is the only person who knows their password. 
  The server concatenates the password with the saved salt 
  associated with the user. This result is then hashed using SHA-2. This hash is 
  compared to the hash associated with the user. If the hash of the password plus 
  salt matches the saved salt, then the user is authenticated. Matching the hashes 
  is sufficient to authenticate the user because SHA-2 is a cryptographically secure 
  hash. This means that SHA-2 has second image resistance; it is 
  infeasible to find a second message y that hashes to the same value as the 
  original value x. This means that if the hashes match, the user must know the 
  real password rather than generating a password that has a matching hash. Using 
  a cryptographically secure hash also means that it has preimage resistance. This
  means that if the Group server is ever compromised, then it would be infeasible 
  for attackers to recover the original passwords from the stolen hashes.  
  <br><br>
  Once established, all communication that occurs between the user and the server 
  will be encrypted by the shared key K. Knowing K is proof that the user is the 
  same user that authenticated previously. The user and server are the only ones 
  that know this key K, and therefore being able to encrypt and decrypt things 
  with K proves that user knows K. 
  <br><br>
  This system is safe from replay attacks. For example if an attacker steals the 
  two messages that are starred. 
  <br><img src="images/passwordreplay.png" class="image"><br>
  Later the attacker sends these two messages to 
  the server at a later time. This will not result in the attacker gaining access 
  to the system. The server will choose a different value of s than it chose when 
  the attacker recorded the messages. This means that the secret key K will be 
  different than the K between Bob and the server and the server will not be able
  to decrypt the message from the attacker, as their K is wrong.
  <br><br>
  In this scenario, group servers are trusted which means that the newuser flag 
  cannot be used to trigger a forced password reset by an attacker. Even if the 
  newuser flag was somehow set, it would not compromise the user account because 
  the user needs to authenticate with the server before changing the password.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Token modification or forgery is a problem in the system that must be addressed. 
  The first example of this would be users requesting a Token from the server and 
  then adding extra groups that they are not allowed to access. This could allow 
  non-ADMIN users to add themselves to the ADMIN and start deleting users or 
  accessing files that other groups are trying to protect. Another scenario would 
  be that users create their own Tokens from scratch that gave them the same kind of 
  permissions as they did in the modification exploit. A final exploit in this 
  category would be saving a Token that had access to a group g then once the user
  was removed from group g for what ever reason it could be used to access group 
  g again.  
</p>
<p>
  The first two problems are solved in the same way. Digital signatures. When a 
  Token is issued by the Group server it will be signed with its private key. Once
  the client passes this signed token to the file server the file server can verify 
  it with the servers public key. The second issue of replaying an old token can 
  be solved with time stamps. The time the token was issued can be concatenated 
  with the token before it was signed. If the file server receives a Token where 
  the time stamp is far off from the current time the file server will know that 
  something is up and can discard the request.
</p>
<p>
  Assuming that the GroupServer is the only one with the private key then we know 
  that a Token signed from the server will be real. Even if a middle party decrypts 
  the Token with the servers public key and changes the Token they will not be 
  able to sign it because they do not have the private key of the server. The time
  stamp solution ensures that very old tokens are not passed off as legitimate.
  There are problems with the time stamp approach like if the attacker attacks the 
  NTP. An attacker this motived seems difficult to deal with in the long run. 
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  An unauthorized file server is a large problem that this system faces. If a user
  tries to connect to server s and instead connects to server s'. If the server s' 
  is unauthorized it probably will not be trusted like a file server would be to 
  behave correctly. This means that an untrusted file server could accept sensitive 
  files for upload but then freely give these files to anyone that asks for them.
  After authenticating a file server there needs to be a way to make sure that you 
  are still communicating with the same server that you authenticated with.
</p>
<p>
  This problem can be solved in the same way that SSH servers are authenticated. 
  The client program will cache the keys of servers that it has connected to in 
  the past. If the servers key is not cached a message displaying the key will be 
  shown to the user. It is then the users responsibility to check that the server
  they are connected to is really the server with said key.<br >
  <img src="images/sshwarning.png" class="image">
  <br>
  Messages to the file server will be encrypted with the server key and sent. This 
  encryption will be RSA. 
</p>
<p>
  This solution works because the users will physically verify the servers. The 
  fact that this is the way servers authenticate ssh means that this method is 
  tried and true. To ensure that we are talking to the same server we authenticated 
  with we used PSA public key cryptography. Assuming that the server is the only 
  one with the other key then our encrypted messages will only be decrypt-able by 
  the server we authenticated with, this means we are always talking to s and not 
  s'. 
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  This threat, information leakage via passive monitoring, is rather easy to 
  defend against. This threat can be thought of as two people talking in a room
  and there being a third person in the room unseen who is listening to their 
  conversation. In the context of our program this means that people could listen 
  to and record the messages once a "DOWNLOADF" message is seen. This would allow 
  the attacker to record the contents of a file being sent to the client even though
  they are most likely not allowed to see this file.
</p>
<p>
  Just how this problem can be framed in a real world scenario the 
  solution can be found in the same way. In the real life example of an 
  eavesdropper the two people talking would simply use another language that the 
  eavesdropper doesn't know. In a similar way the client and the servers will speak 
  there own language using encryption. At the beginning of all communication 
  between the client and one of the servers they will use the Diffie-Hellman 
  protocol to exchange a shared key K. They will then use this key K in symmetric 
  key cryptography system using AES with 128-bit keys. It would be set to any 
  mode besides ECB (which is vulnerable to replay attacks), we would use CBC. These
  keys would be created for each session that a client connects to a server.
</p>
<p>
  This protocol will stop eavesdroppers. At each exchange the user and the server 
  generate a b and a s respectively. These number how ever are only transmitted 
  in the form of g<sup>[b|s]</sup>mod q so an attacker who steal either or both 
  of these they cannot recover g<sup>bs</sup> mod q (K). This means that K is a 
  secret between the two parties and therefore if used for encryption then the 
  third party will not be able to decrypt it. Creating a new key K for each session 
  means that the encryption will be different every time so patterns cannot be used 
  to guess at the content of the messages. 
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didnâ€™t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!
<br><br>
Diagram of all the layers of security we'll use
</p>

<p>If your group did any extra credit, please discuss that in this section, as
well. 
<br><br>
Two factor Authentication?
</p>
<h3>Extra Credit: A public key cryptography authentication protocol.</h3>
<p>
  A system that uses public key cryptography to protect the system from Unauthorized 
  Token Issuance and allows user to login with a RSA Public Key/Private Key pair.
  This system allows for a user to use public key cryptography to log into the 
  system rather than a username and password pair.
  <br>
  In this solution the user's public key is submitted
  to the GroupServer upon the creation of the user account. The user and server 
  create a shared secret K using a signed Diffie-Hellman protocol. This method 
  creates a shared K and authenticates the user and server with each other. <br>
  The protocol would look like so: <br>
  <img src="images/publicauth.png" class="image">
  <br> 
  This protocol uses Diffie-Hellman to create a shared secret key, K, that is 
  computed by both Bob and the Server with the formula g<sup>bs</sup> mod q. b is 
  chosen by Bob with a cryptographically secure random number generator and s is 
  chosen by the server with a cryptographically secure random number generator too.
  Not only do these two messages create a shared key K they also authenticate the 
  user and server to one another. The messages used in Diffie-Hellman will be 
  signed with each participants private key K<sup>-1</sup>. The digital signatures 
  will be done with 2048 bit key RSA because the NSA recently published about a 
  break in 1024 as discussed in class. The symmetric key cryptography system 
  would use AES with 128-bit keys. It would be set to any mode besides ECB 
  (which is vulnerable to replay attacks), we would use CBC. The numbers b and s 
  will be chosen with the java.security.SecureRandom library.
</p>
<p>
  This protocol sufficiently stops attacks of unauthorized Token issuance. The 
  user and the server use Diffie-Hellman to exchange secret keys. At this point 
  the communication between the two cannot be observed by a third party. Assuming 
  that each the user and the server are the only ones that know their own private 
  keys then the ability to encrypt a message that can be decrypted with the senders 
  public keys means that the sender is the real person. The rest of the communication 
  that will occur between the user and the server will be encrypted by the shared 
  key K. Knowing K if proof that the user is the same user that authenticated 
  previously. The user and server are the only ones that know this key K and 
  therefore being able to encrypt and decrypt things with K means that the person 
  knows K. The key exchange is secure because the user and the server 
  generate a b and a s respectively. These numbers however are only transmitted 
  in the form of g<sup>[b|s]</sup>mod q so an attacker who steal either or both 
  of these they cannot recover g<sup>bs</sup> mod q (K). This means that K is a 
  secret between the two parties.
</p>
<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

