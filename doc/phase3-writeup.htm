<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

img.image {
  display: block;
  margin-left: auto;
  margin-right: auto; }
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester (bdl20) </br >
Carmen Condeluci (crc73) </br >
Ryan Conley (rgc11) </br >

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In order to address the threats posed in the Threats T1-T4 our group used a 
wide variety of Cryptographic techniques. We use Symmetric key cryptography to 
stop passive eavesdroppers, public key cryptography for mutual authentication, 
digital signing for token verification, and key exchange protocols such 
Diffie-Hellman to swap session keys. We also use Strong password protocols for a
proposed login method. All notation used in this write-up is derived from
the notation provided to us by Professor Banaan. A "g" represents the group
server, a "u" the user, and an "f" a file server.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Threat 1 (T1) is the threat of an Unauthorized Token Issuance. This threat can 
  be succinctly be described as user Alice requesting (and then 
  obtaining) a token meant for user Bob. It is easy to imagine this scenario being 
  exploited. Attacker Alice tells the Group server that her username is Bob. The 
  group server happily responds with the Token of user Bob. Now when Alice makes a
  request to the file server she can access all the files that Bob is supposed to 
  including 
  ones that she is not supposed to access. In our current insecure implementation 
  a user can set their username to whatever they want and that is what is sent to the 
  group server. Exploiting this is as simple as typing a name in a box. </br>
  <img src="images/FakeUser.png" title="I am really User Alice" class="image"> 
  </br>In this case 
  Attacker Alice has entered User Bob's name in the username field and will be 
  requesting Bob's token instead of her own. In our implementation the request for 
  a Token simply takes a user name and responds with that users Token. This means 
  that Alice using Bob's name will give her Bob's Token.
  <br>
  This threat is not a one time threat. The system must defend from attacker 
  Alice taking a token meant for Bob after Bob has authenticated with the server 
  the initial time. This is the simple scenario of Alice waiting for the actual 
  user Bob to request a token and then Alice could copy the token. This copy could 
  then be used on file servers to access Bob's files.
</p>

<p>
  Our solution is use passwords to protect the system from Unauthorized 
  Token Issuance. 
  <br>
  <!-- User Creation, Justify why ADMIN gives password to user, Describe the 
    implementation of the newuser flag-->
  In this solution an ADMIN picks a password that must be 
  provided to the GroupServer upon user creation. This initial password will be 
  given to the user by the ADMIN. 
  The GroupServer will set a flag in the UserList that this user is new (a newuser 
  flag). This 
  will trigger a forced password change once the user logs on. 
  <!-- Authentication Protocol 
    Key Exchange
    to Argue:
      Diffie Hellman
      Random number selection
      Symmetric encryption to use AES
  -->
  <br>
  Before the user actually authenticates with the server the two must set up secure
  communication over an insecure channel. They do this using Diffie-Hellman to 
  create a shared secret key, <b>K</b> that will be used for symmetric key 
  cryptography.
  This Diffie-Hellman protocol will use these values <b>g</b> = NUMBER and <b>q</b>
   = NUMBER.
  The numbers <b>b</b> and <b>s</b> will be selected at random by Bob and 
  the Server respectively 
  using the java.security.SecureRandom library. The secret key <b>K</b> is computed
   with
  <b>K</b> = g<sup>bs</sup> mod q. This symmetric key cryptography system would 
  use AES with 128-bit keys. AES would be used as a block cypher in CBC mode. CBC 
  is used because ECB is vulnerable to replay attacks.
  This encryption will protect the Tokens from being stolen later after the User 
  Bob authenticates with the system. In order to defend from replay attacks a new 
  shared key <b>K</b> is created every time a user connects to the Group Server. 
  <br>
  <!--
    Password Authentication
    to Argue:
      Salt generation
      Hash Function
      Hashed password || Salt storage
  -->
  Once this shared Key is established and therefore a secure communication channel 
  is setup the server still needs to verify that the client it is talking too who 
  is claiming to be Bob is really Bob. This is done with a password. Using the 
  shared key Bob sends his username and password to the server. Once 
  the server receives the message and decrypts it with the key it will hash the
  password concatenated with a salt that is associated with the username. The 
  server then compares this &lt;username, hash&gt; pair with its database. Both 
  the salt and the hash of the password concatenated with the salt will be stored 
  in the User object associated with that user. The salt will be generated when 
  the saved password is changed. The salt will be generated randomly with the 
  java.security.SecureRandom library. The Hash will be computed using SHA-2 because
  recently SHA-1 has been showing the same weakness that MD-5 did before it was 
  broken. If the hash matches the saved hash then the server responds to Bob with 
  his Token.
  <br>The protocol would look like so: <br>
  <img src="images/password.png" class="image">
  
  When a user has a new user flag set then when the Server authenticates their 
  password the server will also include a "Change Password" message. When this 
  is received by the client the client will prompt the user to select a new 
  password. Once this new password is chosen then it is encrypted and sent back 
  to the server. The server decrypts this new password and will generate a new 
  salt with the same secure random number generate as before. The Server 
  concatenates the new password and the new salt and hashes it with SHA-2. Once 
  this new hash is saved the newuser flag is unset and the server tells the client 
  that the change was a success.
  <br>The new user protocol would look like this</br>
  <img src="images/newuser.png" class="image">  
</p>
<p>
  <!-- Argument that this works
    Need to argue for
      Diffie-Hellman
      Password
      show it defending from replay attack
      The new user flag is not a problem.
  -->

  This protocol sufficiently stops attacks of unauthorized Token issuance. The 
  user and the server use Diffie-Hellman to exchange secret keys. The key exchange 
  is secure because the user and the server generate a <b>b</b> and a <b>s</b>
  respectively. 
  These numbers however are only transmitted in the form of g<sup>[b|s]</sup>mod q 
  so an attacker who steals either or both of these then cannot recover 
  g<sup>bs</sup> mod q (K). This means that K is a secret between the two parties.
  At this point the communication between the two cannot be observed by a third 
  party. Diffie-Hellman is safe to use because figuring out g<sup>bs</sup> mod p 
  from either message is the discrete log problem which is presumed to be hard. 
  <br>
  Once this secure communication channel has been set up the users password can be 
  sent to the server. This password system is sufficient to authenticate a user 
  assuming that the user is the only person who knows their password. 
  The server concatenates the password with the saved salt 
  associated with the user. This result is then hashed using SHA-2. This hash is 
  compared to the hash associated with the user. If the hash of the password plus 
  salt matches the saved salt then the user is authenticated. Matching the hashes 
  is sufficient to authenticate the user because SHA-2 is a cryptographically secure 
  hash. This means that SHA-2 has second image resistance. This means that it is 
  infeasible to find a second message y that hashes to the same value as the 
  original value x. This means that if the hashes match the user must know the 
  real password rather than generating a password that has a matching hash. Using 
  a cryptographically secure hash also means that it has preimage resistance. This
  means that if the Group server is ever compromised then it would be infeasible 
  for attackers to recover the original passwords from the stolen hashes.  
  <br>
  Once established all communication that occurs between the user and the server 
  will be encrypted by the shared key K. Knowing K is proof that the user is the 
  same user that authenticated previously. The user and server are the only ones 
  that know this key K and therefore being able to encrypt and decrypt things 
  with K proves that user knows K. 
  <br>
  This system is safe from replay attacks. For example if an attacker steals the 
  two messages that are stared. 
  <br><img src="images/passwordreplay.png" class="image"><br>
  Later the attacker sends these two messages to 
  the server at a later time. This will not result in the attacker gaining access 
  to the system. The server will choose a different value of s than it chose when 
  the attacker recorded the messages. This means that the secret key K will be 
  different than the K between Bob and the server and the server will not be able
  to decrypt the message from the attacker because K is wrong.
  <br>
  In this scenario group servers are trusted which means that the newuser flag 
  cannot be used to trigger a forced password reset by an attacker. Even if the 
  newuser flag was somehow set it would not compromise the user account because 
  the user needs to authenticate with the server before changing the password.
  <br>
  It is assumed that if the ADMIN of the system chose our system it is because 
  of the security that comes with it. Due to this assumption it is reasonable to 
  assume that the ADMIN will have some method of getting the default password to 
  the user, even email would work if it was encrypted. The main use of this 
  system will be in a work setting so it is also 
  reasonable to assume that the ADMIN could see the user face to face in order to
  disclose the default password to them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->
<p>
  Token modification or forgery is a problem in the system that must be addressed. 
  The first example of this would be users requesting a token from the server and 
  then adding groups to their token that they are not members of, possible in the current
  implementation due to the tokens being stored in memory as plaintext, without any signature. This could allow 
  non-admin users to add themselves to the admin group and abuse those powers by accessing
  files they are not allowed to, creating users, and deleting users. The attacker could also
  add themselves to any other group in the group server, gaining access to files they should
  not have access to and being able to upload files to the group, an abuse of this
  ability being flooding the group's files to make it difficult to locate the group's valid
  files, consuming the group's disk quota, and impersonating other valid documents with false copies.
  Another scenario would be that users or attackers create their own 
  tokens from scratch that grants them the same kind of 
  permissions as they acquired in the modification exploit. A final exploit in this 
  category would be saving a token that had access to a group g, then once the user
  was removed from group g for whatever reason, this saved token could be used to access group 
  g again taking advantage of the exploits outlined above. These threats can manifest themselves
  in the current implementation by having the user edit their token before sending it 
  to the file server. They can also save their tokens and reuse them at anytime. A token can be 
  forged by knowing the issuer (which is trivial to discover) the username of the user you wish
  to impersonate, and the names of the groups an attacker may desire access to. All of this information
  is available. These modified, forged, or reused tokens can then be used with the file server.
</p>
<p>
  The first two problems of token modification and forgery are solved in the same way: digital signatures. 
  When a token is issued by the group server it will be hashed, and this hash 
  will be signed with the group server's private RSA key. The token is 
  hashed because of the variable length of tokens,
  which may be quite large due to variance in the size of the strings of the issuer, 
  username, and group names, and the number of groups. In order for all of this to occur
  there must be an agreeed upon serialization of the token between the group server and the file server
  so that when the group server hashes the token and signs the hash, the file server is
  able to hash the token in the same manner and compare its own hash with the 
  decrypted hash of the group server. There also must be an agreed upon hashing algorithm
  between the group server and the file server, so the hash will be created symmetrically. 
  For our implementation we will be using the SHA-2 with a 256 bit digest (SHA-256),
  which is, at the present moment, known to be secure and is forecasted to continue to be for
  the near future (more than a couple of years). The serialization of the
  token will occur by concatenating the 
  issuer, followed by the user, followed by all of the groups the user belongs to.
  It will appear as follows: issuer || user || groups
  The authentication message the user sends to the file server along with its group token will
  be the token itself concatenated with the signed hash of the token, and this message encrypted
  with the symmetric key generated from the user-file server Diffie-Hellmann exchange.
  Once the client passes this token along with the signed token to the 
  file server the file server can verify it with the servers public key. 
  A file server will have knowledge of the group server's
  public RSA key upon its creation, to be entered by the user who creates the file server.
  This is reasonable as by the nature of the key being public, there does not need to exist
  any security in the distribution of this public key. This is reasonable in our
  scenario to expect users who wish to create a new file server to have knowledge of the group server's
  public key, as the user must have knowledge of the group server's public key in
  order to authenticate the group server. The third issue mentioned of reusing an old token can 
  be solved with timestamps. This acheives freshness for a token and mitigates the threat of
  a replay attack of the token by only allowing a certain token to be used within a small
  and reasonable frame of time for it to be transmitted securely over the network,
  on the order of a couple of seconds. The time the token was issued can be concatenated 
  with the token before it was signed. This changes the aformentioned serialization
  by adding in the concatentation of the timestamp, which will also be used in the signed hash
  the group server creates, and so the agreed upon scheme between the group server and file server
  must be modified to account for this measure. It will be modified by appending
  the previous token scheme to the timestamp. So the serialization and subsequent transmission
  to the user to be used with the file server within the time frame will appear as follows:
   { timestamp || token || [timestamp || token]K<sub>g</sub><sup>-1</sup> }K<sub>uf</sub>
  If the file server receives a token where 
  the timestamp is outside of the time frame given the current time, then the file server will know 
  the token has been tampered with or that the received token is an expired token
  attempting to be reused, and in both cases, the token is discarded by the file server
  and the user attempting the connection is refused. By including the timestamp in the signed hash,
  it guarantees the token cannot be tampered with without the file server being able
  to verify its modification.
  <br>An example of how this verification works:
  <img src="images/TokenVerification.png" class="image">
</p>
<p>
  Assuming that the group server is the only one with the private key then we know 
  that a hashed token signed from the server will have been issued by the group server. Even if a middle party decrypts 
  the token with the server's public key and alters the token they will not be 
  able to sign it properly because they do not have the private key of the server. The timestamp 
  solution ensures that old tokens are not passed off as legitimate at a later time by checking
  that the token is received by the file server within the time frame (a couple of seconds).
  It is also then known that this timestamp has not been altered due to it being incorporated in the signed hash
  of the entire authentication request. There are problems with the timestamp approach like if the attacker attacks the 
  NTP and is able to change the time for the file server to be within the time frame for
  which the token will be valid. An attacker this motived is able to bypass the described system,
  so we rely on the assumption that the NTP and its connection to the file server is secure, and
  this assumption can safely trusted to hold true.
  Another concern is being certain that the group server and the file servers are in-sync, 
  but the integrity of this is trusted to be maintained by the NTP, with all timestamps being UTC,
  thus keeping any difference in times that may arise to be within a small and acceptable margin of error. 
  Lastly, a man in the middle attacker who operates quick enough to pass along the authentication request
  to the file server so as to be within the allowed time frame would be able to compromise
  the system, this also proves problematic, in that the time frame cannot be made so small
  that requests to the file server are thrown away when they are valid, but not so large
  as to be able to be replayed. This is prevented by all communication between a client
  and a server being precluded by the Diffie-Hellman protocol demonstrated prior, with all
  subsequent communication being encrypted with the generated symmetric key.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  An unauthorized file server is a large problem that this system faces. For example, a user
  tries to connect to server s and instead connects to server s'. If the server s' 
  is unauthorized, it probably will not be trusted like a file server would be to 
  behave correctly. This means that an untrusted file server could accept sensitive 
  files for upload, but then freely give these files to anyone that asks for them.
  After authenticating a file server, there needs to be a way to make sure that you 
  are still communicating with the same server that you authenticated with.
</p>
<p>
  This problem can be solved in the same way that SSH servers are authenticated. 
  The client program will cache the keys of servers that it has connected to in 
  the past. If the servers key is not cached, a message displaying the key will be 
  shown to the user. It is then the users responsibility to check that the server
  they are connected to is really the server with said key.<br><br>
  <img src="images/sshwarning.png" class="image">
  <br>
  Messages to the file server will be encrypted with the server key and sent. This 
  encryption will be RSA. 
</p>
<p>
  Before any sort of authentication with the file server takes place, Bob and 
  the file server must first set up a secure communication over an insecure channel.
  This is accomplished using the Diffie-Hellman protocol to create a shared session key,
  K, that will be used for the remainder of their session for symmetric key cryptography.
  This Diffie-Hellman protocol will use the values <b>g</b> = NUMBER and <b>q</b> = 
  NUMBER, with the values of <b>b</b> and <b>s</b> being generated at random with the
  java.security.SecureRandom library by Bob and the file server, respectively. 
  Just like in our password authentication solution above, the secret session key 
  <b>K</b> will be computed with <b>K</b> = g<sup>bs</sup> mod q. We will employ AES 
  with 128-bit keys for our symmetric key cryptography system for this session key.
  Again, AES would be used as a block cipher in CBC mode, as ECB is vulnerable to 
  replay attacks. This per-session encryption will prevent a rogue file server from 
  hijacking the connection after the file server has already been authenticated. 
  By generating a new session key, <b>K</b>, each time a user connects to a file 
  server, replay attacks are also defended against.
</p>
<p>
  After this secure communication channel is established with its session key, 
  Bob needs to verify that the file server he is connecting to is indeed 
  the file server they claim to be. This can be accomplished with public key 
  cryptography via RSA with 2048-bit keys, as 1024-bit RSA keys were recently proven 
  by the NSA to be insecure. The file server first sends Bob its public RSA key, 
  <b>K<sub>s</sub></b>, encrypted with the session key, <b>K</b>. Upon receiving 
  this message, Bob decrypts <b>K<sub>s</sub></b> and then checks his cached table 
  of &lt;hostname:port, public_key&gt; pairs for a match. 

  <br><br>

  If a match is found, Bob sends a message to the file server containing a challenge, 
  <b>R1</b>, encrypted with the file server's public key, <b>K<sub>s</sub></b>. This 
  is then further encrypted with the session key, <b>K</b>. The file server then 
  decrypts this message using both the session key and its private RSA key, then 
  sends back to Bob the challenge <b>R1</b> encrypted with the session key. If the 
  challenge was successfully decrypted by the file server, Bob can be certain that 
  the file server is legitimate and sends a message of success to the file server. 
  From this point, all communication between Bob and the file server is secured using 
  the session key until the connection is terminated.

  <br><br>
  The interactions between Bob and the file server are visually represented as follows:
  <br><br>

   <img src="images/matchfound.png" class="image">

  <br><br>

  If a match is NOT found, Bob will view a message with information regarding the 
  file server he is attempting to authenticate, which would include the following: 

  <ul>
    <li>File Server Hostname</li>
    <li>Recieved RSA Public Key</li>
    <li>Cached RSA Public Key (if available)</li>
    <li>Warnings and Directives</li>
    <li>Options to Connect or Abort</li>
  </ul>

  If a pair exists in Bob's cache that includes a matching file server IP address, 
  but a mismatched public RSA key, it can be concluded that the file server is 
  more than likely illegitimate and the connection should be aborted. If a pair does 
  NOT exist with any matches, this is the first connection of Bob to that particular 
  file server, and the file server requires physical verification by Bob to continue 
  the connection process. However, if Bob selects to abort the connection to the file 
  server, the session is terminated and the connection is dropped.

  <br><br>
  Both these cases can be represented by the following diagram:
  <br><br>

   <img src="images/mismatch.png" class="image">

  <br><br>

  If Bob selects to continue the connection process, he 
  will send a a message to the file server containing a challenge, 
  <b>R1</b>, encrypted with the file server's public key, <b>K<sub>s</sub></b>. This 
  is then further encrypted with the session key, <b>K</b>. The file server then 
  decrypts this message using both the session key and its private RSA key, then 
  sends back to Bob the challenge <b>R1</b> encrypted with the session key. If the 
  challenge was successfully decrypted by the file server, the file server 
  is authenticated and Bob sends a message of success to the file server. Bob also 
  adds a new pair to his cached table of &lt;hostname:port, public_key&gt; 
  to reflect the new verified server. Bob and the file server are then free to 
  communicate using their session key until the connection is terminated.

  <br><br>
  This case is represented by the following diagram:
  <br><br>

   <img src="images/physicalverify.png" class="image">

  <br><br>

  <p>
  This solution works because the users will physically verify the servers. The 
  fact that this similar to the way servers authenticate SSH means that this method is 
  "tried and true". To ensure that we are talking to the same server we authenticated 
  with, we have used RSA public key cryptography in tandem with symmetric key 
  cryptography. Assuming that the server is the only one with the other key, then our 
  encrypted messages will only be decrypt-able by the server we authenticated with, 
  this means we are always talking to <b>s</b> and not <b>s'</b>. Both during and after 
  the authentication process, we can ensure safe communication between the user and the 
  file server with the Diffie-Hellman protocol, as it is proven safe by the discrete 
  logarithm problem. Although it would be preferred to not require users to keep cached 
  tables and perform physical verification, it is justified within this context due to 
  our system's infrastucture. As group servers cannot be expected to have any information 
  about the (possible) multitude of file servers, and the fact that any user can run a 
  file server, a solution that only involves communication between the user and the file 
  server itself is required. When the user receives a mismatched public RSA key when they 
  already have a previous record of that file server's correct key, they are immediately 
  alerted to their attempt to connect to an <b>s'</b> file server. After the server has 
  been authenticated by the user, their further communication is secure under their 
  previously generated session key.
  </p>

</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  Information leakage via passive monitoring is a threat whose counter-measures
  have already been partially addressed through the satisfaction of the other threats
  by way of the Diffie-Hellman protocol. 
  This threat can be thought of as two people talking in a room
  and there being a third person in the room unseen who is listening to their 
  conversation. In the context of our program this means that people could listen 
  to and record the messages being relayed between the clieant and the server.
  With no measures taken to prevent this, it leaves the file sharing system vulnerable
  to such an attacker who may exploit it by stealing tokens or the contents and data being transmitted.
  With stolen tokens, if the attacker were to use that token with a file server within
  the given time frame, they could receive unauthorized information from the file server.
  By stealing tokens, it is reasonable to assume they could then modify these
  stolen tokens to suit whatever purposes they wish. Another threat is that a file 
  may be stolen during a download or upload operation, exposing sensitive content
  to an attacker. Only the server and the authorized requesting user should have access
  to this information, as it is assumed in the threat model that administrator's
  only functions is to monitor and maintain the file sharing system itself,
  not the contents therein.
  A more generalized threat information leakage poses is that any information leaked to attackers
  can provide information about the system's functions that may aide in some other attack.
<p>
  Just how this problem can be framed in a real world scenario the 
  solution can be found in the same way. In the real life example of an 
  eavesdropper the two people talking would simply use another language that the 
  eavesdropper doesn't know. In a similar way the client and the servers will speak 
  their own language using encryption. At the beginning of all communication 
  between the client and one of the servers they will use the Diffie-Hellman 
  protocol to create a shared symmetric key K. They will then use this key K in a symmetric 
  key cryptography system using AES with 128-bit keys, which is found to be secure at the present time. 
  It would be set to any mode besides ECB (which is vulnerable to replay attacks), and we will use CBC.
  These keys are generated for each interaction between a server and a client,
  meaing this protocol is carried out 1 time between a user u and the group server
  g, and n times, a separate instance of the protocol for each of the n file servers
  the user may wish to connect to. This means that the client, the group server, and the
  file servers must all keep track of their symmetric keys and their respective
  correspondents, and these keys are discarded and never used again after disconnection.
  We must then establish the values g, the shared root to be raised to a randomly generated value
  and, and p, the value by which this exponentiation is moduloed by.
  The value g is chosen to be a prime number that is a primitive root of p, in other words,
  g is a generator of the multiplicative group of integers modulo n, so more generally
  this means that g can produce all p-1 values depending on the exponent it is raised to. This is done to minimize
  the likelihood of guessing the power g was raised to modulo p. The value p is chosen to be
  a large prime number that is slightly less than a power of 2. This is mainly used
  for encrypted key exchange protocols, where the number g<sup>random chosen number</sup> % p is
  enrypted using a weak secret, making an attacker unable to throw out most of the guessed
  weak secrets to decrypt the value g<sup>random chosen number</sup> % p. Our chosen
  value p here will be chosen to satisfy this property in order to allow for the system
  to remain extensible in the event that such changes are chosen to implemented.
</p>
<p>
  This protocol will stop eavesdroppers. At each exchange the user and the server 
  generate a "b" and an "s" respectively. These numbers however are only transmitted 
  in the form of g<sup>[b|s]</sup>mod p so an attacker who steals either or both 
  of these they cannot recover g<sup>bs</sup> mod p (K), but the user and the server
  can generate g<sup>bs</sup> mod p by multiplying the received value by their own randomly
  chosen exponent, thus guaranteeing correctness. This protocol relies on the assumption
  that both the server and the user will be able to keep their respective values of
  b and s secret in order for it to be secure, as having one exposed could compromise the key for that session.
  This means that K is a secret between the two parties and therefore if used for encryption then the 
  third party will not be able to decrypt it when operating under these assumptions. 
  Creating a new key K for each session means that the encryption will be different 
  everytime, so patterns cannot be used to guess at the content of the messages and
  if a session key K is compromised, it can only be used to decrypt the messages
  exchanged during that session, providing forward secrecy.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!
<br><br>
Diagram of all the layers of security we'll use
</p>

<p>If your group did any extra credit, please discuss that in this section, as
well. 
<br><br>
Two factor Authentication?
</p>
<h3>Extra Credit: A public key cryptography authentication protocol.</h3>
<p>
  A system that uses public key cryptography to protect the system from Unauthorized 
  Token Issuance and allows user to login with a RSA Public Key/Private Key pair.
  This system allows for a user to use public key cryptography to log into the 
  system rather than a username and password pair.
  <br>
  In this solution the user's public key is submitted
  to the GroupServer upon the creation of the user account. The user and server 
  create a shared secret K using a signed Diffie-Hellman protocol. This method 
  creates a shared K and authenticates the user and server with each other. <br>
  The protocol would look like so: <br>
  <img src="images/publicauth.png" class="image">
  <br> 
  This protocol uses Diffie-Hellman to create a shared secret key, <b>K</b>, that is 
  computed by both Bob and the Server with the formula g<sup>bs</sup> mod q. b is 
  chosen by Bob with a cryptographically secure random number generator and s is 
  chosen by the server with a cryptographically secure random number generator too.
  Not only do these two messages create a shared key K they also authenticate the 
  user and server to one another. The messages used in Diffie-Hellman will be 
  signed with each participants private key K<sup>-1</sup>. The digital signatures 
  will be done with 2048 bit key RSA because the NSA recently published about a 
  break in 1024 as discussed in class. The symmetric key cryptography system 
  would use AES with 128-bit keys. It would be set to any mode besides ECB 
  (which is vulnerable to replay attacks), we would use CBC. The numbers b and s 
  will be chosen with the java.security.SecureRandom library.
</p>
<p>
  This protocol sufficiently stops attacks of unauthorized Token issuance. The 
  user and the server use Diffie-Hellman to exchange secret keys. At this point 
  the communication between the two cannot be observed by a third party. Assuming 
  that each the user and the server are the only ones that know their own private 
  keys then the ability to encrypt a message that can be decrypted with the senders 
  public keys means that the sender is the real person. The rest of the communication 
  that will occur between the user and the server will be encrypted by the shared 
  key K. Knowing K if proof that the user is the same user that authenticated 
  previously. The user and server are the only ones that know this key K and 
  therefore being able to encrypt and decrypt things with K means that the person 
  knows K. The key exchange is secure because the user and the server 
  generate a b and a s respectively. These numbers however are only transmitted 
  in the form of g<sup>[b|s]</sup>mod q so an attacker who steal either or both 
  of these they cannot recover g<sup>bs</sup> mod q (K). This means that K is a 
  secret between the two parties.
</p>
<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

