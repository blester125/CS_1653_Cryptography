<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester (bdl20)
Carmen Condeluci (crc73)
Ryan Conley (rgc11)

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T5–T7.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<!---<p>Begin this section by describing threat T5. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p> -->
<p>
Threat 5 is the threat of Message Reorder, Replay, or Modification by an attacker on the system. These kind of attacks often manifest as a Man in the Middle attack where each of the non malicious entities believe they are talking to each other when really they are talking to the Man in the Middle. This can lead to them disclosing sensitive information to the attacker. This threat could easily be realized in our current implementation. For example, during user authentication the user preforms Diffie-Hellman key exchange with the groupserver to create a shared secret <b>k</b>. The user then sends their username and password encrypted with <b>k</b>. The problem is what if the user is not talking to the groupserver? The user would then establish a shared key <b>k'</b> with the attacker (because the g and q in Diffie-Hellman are public knowledge an attacker could easily implement a Difie-Hellman protocol that would work with ours). The user then sends their username and password encrypted with <b>k'</b>. This means that the attack now has the users username and password and could log on to the server as the user.
<br>
In the case of reordering attacks this could manifest as the attacker sending the wrong message to try to mess with the system hoping to cause an error when the system is presented with unexpected input.
</p>

<p>
We stop this attack using public key cryptography and signed Diffie-Hellman key exchange. There are two communications that needs to be protected this way. The first is the communication between the groupserver and the client. When a user account is created it will be the ADMIN of the groupserver's responsibility to get the users public key that they will use to log into the system with. This public key will be stored in the User object on the groupserver. It will the User's responsibility to get the groupserver's public key when they are configuring their client application. This is similar to the way ssh works. Once each party has each others public keys they can use signed Diffie-Hellman to exchange a symmetric key. The fact that this Diffie-Hellman is signed authenticates the user and the groupserver to one another. The exchanged key is used to encrypt all further messages. <b>INSERT IMAGE HERE</b>
<br>
The second communication that needs to be protected is the communication between the user and the fileserver. There are too many fileservers to the client to be expected to know them all therefore the fileserver's public key must be exchanged. This is done by the user connecting to the fileserver and requesting the fileservers public key. This is then sent to the user who must verify it out of band like in SSH. Once the user has verified the key the user will send their key encrypted with the fileservers public key. This encryption will stop an attacker from modifying the user's public key. Once the public keys are exchanged then the user and the fileserver preform Diffie-Hellman to establish a shared key that is used to encrypt the rest of the messages between the targets.
<br>
Message reordering will be defended against by having checks in the servers that gracefully handle the wrong message rather than having some sort of software crash that could compromise the system. 
</p>

<p>
These defenses are sufficient to stop the threat. Signed Diffie-Hellmen defeats the Man in the Middle attack because the g<sup>x</sup>mod q's are digitally signed. This means that while an attacker could unsign the message but they could not modify it then resign it because they do not know the private key used to sign the message. This means that the message must be coming from the party that it is supposed to be coming from. 
<br>
The key verification out of band is used to stop an attacker from swapping their key with the server's key. If they managed to do this then the user could assume that the signed message is from the server but it is really signed with the attackers private key. This cannot happen because the user verifies the key out of band so they always verify that the keys are correct.
<br>
Having code that gracefully handles unexpected input means that unexpected crashes will not occur that could compromise system integrity.
</p>  


<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<p>Repeat the steps as for Threat T5.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>Repeat the steps as for Threat T5.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

