<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester, bdl20@pitt.edu <br>
Ryan Conley, rgc11@pitt.edu <br>
Carmen Condeluci, crc73@pitt.edu <br>

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T5–T7.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<!---<p>Begin this section by describing threat T5. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p> -->
<p>
Threat 5 is the threat of Message Reorder, Replay, or Modification by an attacker on the system. These kind of attacks often manifest as a Man in the Middle attack where each of the non malicious entities believe they are talking to each other when really they are talking to the Man in the Middle. This can lead to them disclosing sensitive information to the attacker. This threat could easily be realized in our current implementation. For example, during user authentication the user preforms Diffie-Hellman key exchange with the groupserver to create a shared secret <b>k</b>. The user then sends their username and password encrypted with <b>k</b>. The problem is what if the user is not talking to the groupserver? The user would then establish a shared key <b>k'</b> with the attacker (because the g and q in Diffie-Hellman are public knowledge an attacker could easily implement a Diffie-Hellman protocol that would work with ours). The user then sends their username and password encrypted with <b>k'</b>. This means that the attack now has the users username and password and could log on to the server as the user.
<br>
In the case of reordering attacks this could manifest as the attacker sending the wrong message to try to mess with the system hoping to cause an error when the system is presented with unexpected input.
</p>

<p>
We stop this attack using public key cryptography and signed Diffie-Hellman key exchange. There are two communications that needs to be protected this way. The first is the communication between the groupserver and the client. When a user account is created it will be the ADMIN of the groupserver's responsibility to get the users public key that they will use to log into the system with. This public key will be stored in the User object on the groupserver. It will the User's responsibility to get the groupserver's public key when they are configuring their client application. This is similar to the way ssh works. Once each party has each others public keys they can use signed Diffie-Hellman to exchange a symmetric key. The fact that this Diffie-Hellman is signed authenticates the user and the groupserver to one another. The exchanged key is used to encrypt all further messages. <br><br>
<img src="images/signeddh.png">
<br>
<br>
The second communication that needs to be protected is the communication between the user and the fileserver. There are too many fileservers to the client to be expected to know them all therefore the fileserver's public key must be exchanged. This is done by the user connecting to the fileserver and requesting the fileservers public key. This is then sent to the user who must verify it out of band like in SSH. Once the user has verified the key the user will send their key encrypted with the fileservers public key. This encryption will stop an attacker from modifying the user's public key. Once the public keys are exchanged then the user and the fileserver preform Diffie-Hellman to establish a shared key that is used to encrypt the rest of the messages between the targets.
<br><br>
<img src="images/fileserversigneddh.png">
<br>
<br>
Message reordering will be defended against by having checks in the servers that gracefully handle the wrong message rather than having some sort of software crash that could compromise the system. 
</p>

<p>
These defenses are sufficient to stop the threat. Signed Diffie-Hellmen defeats the Man in the Middle attack because the g<sup>x</sup>mod q's are digitally signed. This means that while an attacker could unsign the message but they could not modify it then resign it because they do not know the private key used to sign the message. This means that the message must be coming from the party that it is supposed to be coming from. 
<br>
The key verification out of band is used to stop an attacker from swapping their key with the server's key. If they managed to do this then the user could assume that the signed message is from the server but it is really signed with the attackers private key. This cannot happen because the user verifies the key out of band so they always verify that the keys are correct.
<br>
Having code that gracefully handles unexpected input means that unexpected crashes will not occur that could compromise system integrity.
</p>  


<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<p>
Threat 6 is the threat of file leakage by the file servers. In this phase of the project, it is assumed that
file server are largely untrusted, and in this way they may attempt to leak files to unauthorized
users or attackers. Under this assumption of untrusted file servers that are unable to protect
a group's files from unauthorized principals, a fundamental property of the group
file sharing system is undermined: only the current members of the group may access the group's files,
and the secrecy of a group's files must remain intact as the group changes. This means that when
a member of the group leaves, though they will still have access to all files up until
their termination from the group, as it can't be prevent for a group member to save a file locally,
if a file is leaked by the untrusted file servers to this past group member, they
should be unable to decrypt the files that were uploaded after said termination. 
In addition, when a new member joins a group, they should be able to view all files
from before their joining and all files following until their termination from the group.
What this necessitates is an evolving key to encrypt files with that evolves as the members
of the group evolves.
</p>
<p>
In order to protect against this threat, the primary mechanism we will employ is that of the
Leslie-Lamport one-time password scheme. What this scheme does is allow for a password
to be modified a chosen number of times to create a new password by continually hashing it.
How this works is by starting with a kind of "root" password, which will then be hashed an x
amount of times. Everytime a new password is required, which in the case of our group file sharing system
being when a member of a group leaves, the root password is hashed one less time than what was previously being
used and is used to encrypt/decrypt all files from the time after the group member left the group.
What this means is that at a time t<sub>i</sub>, with group members g and key k<sub>i</sub>,
all the files will be encrypted with a key that is k<sub>j</sub> where the number of hashes for j &ge; i.
So the client who is a member of g will be provided with the most recent key k<sub>i</sub>
and all files that are currently uploaded to the group at t<sub>i</sub> can be calculated by
hashing k<sub>i</sub> n times where n = j-i. When a member leaves the group, the key must evolve
so that the member who left the group cannot calculate this new password if the file server were to leak
the files to this now unauthorized group member. When a new member joins the group, they will be
provided with the most recent key, from which, they can calculate the old keys that older files may be encrypted with.
The problem arises that a group must begin with a key that is hashed a finite number of times, where that key
evolves by decreasing the number of times the root key is hashed until it reaches zero and
the root key itself will become the most recent key. In order to maintain file security
as a group evolves after this point is reached, a new root key must be established, begining the process
once more. Now, a list of keys must be maintained by the group server and passed off to authorized group members.
The list being all past root keys and the current key. From this, a group member will have access to all of the group's
files and be able to upload new files that other members of the group can decrypt. The meta-data for a file
indicating which key and which version of the key were used for encryption are stored with the file in the file list.
The meta-data will also include an IV field indicating a unique initialization vector for that file.
To download a document, a user will download the document, including its associated meta-data of key and key version,
and with its list of old root keys and the current key obtained from the group server, the user will be able to recalculate that key
and decrypt the file. File upload is done by encrypting the file with the most recent key so past group members
cannot decrypt it if the untrusted file server happens to leak said file. Our cryptographically secure hash algorithm
is SHA-2 with a 256 bit digest. The key that will be generated from
this one-time password scheme will be a 128-bit AES key. The files will be encrypted/decrypted with CBC mode, PKCS5 padding scheme, 
and a unique IV for each file.
<br><br>
<img src="images/file_leakge.png">
<br><br>
</p>
<p>
This protocol is correct as any authorized group member who wished to decrypt a file will be able to as all files
a group member is authorized to decrypt is encrypted with a key that is either the present key provided to them by the group server,
a past key version of this key which is obtained by hashing the current key the necessary amount of times, or an old key which hash
used all of its versions and this old key which is hashed zero times can be hashed the necessary number of times to compute an old key
version from a key which has been expended due to group membership changes. It can be said to be secure due to our other mechanisms in place
which are said to be secure under the present threat model. What this means is that only an authorized user for thaat user's authorized groups
can obtain the present keys and the list of old keys for their groups. It cannot be prevent that once a user is removed from a group
that they can no longer view the files that were uploaded to the file server prior to their
removal from the group due to the user storing them on their local machine, however, they will be unable to decrypt files uploaded
to a file server in the future for the group due to the preimage of resistance of SHA-2, which is at the present considered to be
a cryptographically secure hash function. Furthermore, if one of the keys is compromised by an attacker they will only be able to decrypt
messages uploaded at in the current group version, or prior, and what's more is that the compromise of one key also limits this to only being
valuable to a maximum of 100 group version. The number of key evolutions was chosen by weighing the time it takes to repeatedly hash
a value some number of times relative to the time it takes to decrypt a file and the size of they key list for a group
that will need to be maintained by the file server relative to how many group versions may come to exist for a group.
There are 100 versions of a key per root key including the root key, meaning the client will have to hash the password at most
99 times. This is thought to be a reasonable number, as the cost of decrypting a file will almost always eclipse the cost of these hashes
for all but the smallest of files. This value also allows for 100 group members to leave a group before a new key is needed. It is doubtful
that such a group will exist such that the group server will need to maintain a lengthy list of old keys. Forward secrecy is a concern,
but is less prioiritized over the group server storage (which should be fairly sparse) as the system is thought to be secure under the
current threat model, making the event of a key leak to be extremely unlikely. A unique IV is associated with each IV so that no
sort of codebook can be built up, leading to malicious file insertions or detections of the semantics or semantic changes within files.
A proper padding scheme is used to maintain the security of the encryption and bring the file size to the correct bit multiple. Symmetric key
cryptography with a 128-bit AES key is used in CBC mode due to the speed of symmetric key cryptography and the propagation of the cipher text
to the rest of the encryption (as hard drive storage should be relatively error free). Though the IV and group meta-data 
(key information) do not need to remain secret, they will still be encrypted with an established shared symmetric key 
as outlined in the prior phase, in-keeping with our pattern. AES with a 128-bit key has no known vulnerabilities or breaks at this time,
and is being used for all symmetric keys in the system, and so here too. 
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>
The threat of token theft by a file server is a security problem that our 
system faces, as we must assume from our threat model that file servers are 
largely untrusted. If a rogue file server were to capture and distribute a user's 
token, attackers in control of this token could utilize it to perform operations
 such as adding themselves to the "ADMIN" group, add or remove other users from 
groups, upload/download files freely, and generally have access to any functionality 
that was granted to the original owner of the stolen token. This stolen token could 
also be utilized on multiple different servers outside of the rogue server that 
distributed it, which would effectively compromise the entire system. Although this is 
a similar security threat to those we have addressed in previous phases (T2), the 
tokens in this scenario are unmodified and genuine, as in, they are not forged or 
altered by malicious users. To combat this security issue, a system that ensures 
tokens cannot be utilized outside of their destinations (in this case, the file 
server) is required in order to protect against this threat.
</p>

<p>
The first step in implementing a mechanism to solve the issue of token theft is a 
solution that we previously implemented in response to T2 in Phase 3. Tokens include 
the following information in our Phase 3 implementation: issuer, subject, group list, 
a hash of the token digitally signed with the group server's private key, and most 
importantly, a timestamp. This timestamp achieves freshness for the token, making it 
impossible to utilize the token after the window of network tolerance expires (10 
seconds in our implementation). An attacker cannot modify the timestamp, as the 
timestamp is included in the hash of the token. As previously outlined in Phase 3, 
the agreed-upon serialization of the token is a concatenation of the issuer, subject, 
group list, and timestamp with each section separated by a sentinal character ("#" 
in our implementation) that is disallowed from use in any of the sections. The token 
will appear as follows: { token || [token]K<sub>g</sub><sup>-1</sup> }K<sub>uf</sub>, where the token = timestamp || issuer || subject || groups with each section 
separated with the "#" sign, as well as each group being delimited too.
Just as in Phase 3, we will be using SHA-2 with a 256-bit digest (SHA-256), which is, 
at the present momement, known to be secure and is forecasted to continue to be so 
in the near future. By restricting the time window in which a token can be utilized, 
it reduces the feasibility of a large-scale compromise of the system to only those 
that can be conducted completely within the window of network tolerance.
</p>

<p>
However, timestamps alone are not enough to protect against this threat, as a file 
server could possibly distribute a stolen token to an attacker, with that attacker 
quickly adding themself to whatever groups the original owner of the token had 
permission to add users to. If this is achieved within the time-frame of the 
network tolerance, the attacker can then freely perform all the group and file 
operations it can with their newfound permissions even after the stolen token has 
"expired". As we need to ensure that tokens cannot be used outside their destination, 
then the solution is to add the intended destination of the token to the token 
itself as an additional section. In this case, the destination will be the 
"hostname:port" string of the intended file or group server (with which the client is 
already connected and authenticated with) that the user is attempting to perform 
an operation with. The client will send this information along with their username 
to the group server when they request a token, which will return to them a token 
generated with this destination information as well as a digitally signed hash (
with the group server's private key) of the serialization of the token. The returned 
token will appear as follows: { token || [token]K<sub>g</sub><sup>-1</sup> }K<sub>
uf</sub>, where the token = timestamp || destination || issuer || subject || groups 
with each section separated with the "#" sign, as well as each group being delimited 
too. With this new destination information and its inclusion into the signed hash, 
a server will be able to verify that a token can only be used within the server 
that they are meant to, as tokens are already secured to be un-modifiable.
</p>

<p>
One question that stands out when considering the implications of this destination 
field is: "What is stopping the file servers from simply ignoring the destination 
field of the token?" Our trust model states that file servers are largely untrusted.
The destination field certainly ensures that stolen tokens will not be able to be used to 
complete any group operations, as the group server is assumed to be trustworthy, but a 
malicious file server may ignore it. The solution to this issue can be realized by 
considering that if a file server cannot be trusted to enforce these restrictions, 
they cannot be trusted with any files existing on their server either (as outlined 
in T6). By protecting against the threat of file leakage by a malicious server in T6, 
we can assume that any files that are leaked by malicious servers, even if they use a 
stolen token and ignore the destination field, are still unusable by attackers. 
</p>

<p>
Overall, this defense mechanism adequately addresses the threat of token theft. 
By including both a timestamp and the intended token destination in the token itself, 
the stolen token cannot be feasibly distributed or used to allow attackers to gain 
permissions on both the group server or other file servers. As outlined in our previous 
phase (Phase 3), tokens are made to be un-modifiable via a digitally signed hash of 
an agreed-upon serialization of the complete token (T2), so a stolen token cannot be 
modified in an attempt to attack these new restrictions.
</p>
<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

