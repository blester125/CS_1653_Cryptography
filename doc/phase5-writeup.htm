<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P5 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P5 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Brian Lester, bdl20@pitt.edu <br>
Ryan Conley, rgc11@pitt.edu <br>
Carmen Condeluci, crc73@pitt.edu <br>

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>Most of the threats outlined in this section revolve around the untrustworthiness of the machines that the group/file server run on. The trust models for the individual parts break down like this: <br><b>Group Server:</b> The group server is still entirely trustworthy.<br><b>File Server:</b> The file server is trust for the same things that it is trusted in part 4 of the project. The difference is that it is no longer trusted to not modify the files on disk.<br><b>Clients:</b> Clients are still entirely untrusted.<br><b>Machines that the programs are run on:</b> These are entirely untrusted.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threatmodel">
      <h2>Threat Model</h2>
<!-- BEGIN CHANGES HERE -->

<p>Define a threat model within which your implementation is subject to attack.
You may re-use a threat model from another phase of the project, or you may
define a new threat model (e.g., What if we were worried about more than just
the file leakage from a file server? What if the group server was mostly
trusted, but the password file or other state was somehow leaked? What about the
possibility of DoS or DDoS attacks?). This threat model should be written up in
the same format as the threat models that you were given for Phases P3 and P4 of
the project.</p>


    <section id="threat8">
      <h2>Threat T8: Snooping System Admin</h2>
<!-- BEGIN CHANGES HERE -->
<p>This threat model is that a System Admin (or anyone that is using the machine that the group model is running on) could read or modify the GroupList and the UserList that the group server uses to save state.</p>

<!-- END CHANGES HERE -->
    </section>

    <section id="threat9">
      <h2>Threat T9: Theft of the Groupserver private key</h2>
<!-- BEGIN CHANGES HERE -->
<p>This threat model is that a user on the machine that the group server is running on could steal the group servers private key from the "groupserverprivate.key" file</p>

<!-- END CHANGES HERE -->
    </section>

    <section id="threat10">
      <h2>Threat T10: File Modification</h2>
<!-- BEGIN CHANGES HERE -->
Due to the untrusted nature of the file server and the untrusted machine it is running on a file that is saved to disk could be modified.

<!-- END CHANGES HERE -->
    </section>

    <section id="threat11">
      <h2>Threat T11: Unprotected File Server Key</h2>
<!-- BEGIN CHANGES HERE -->
<p>
This threat is that a user on the file server machine could steal the file 
servers private key from the "fileserverprivate.key" file.
</p>

<p>
Our current implementation of file servers provide no protection against the 
theft of a file server's private RSA key (in the case of the machine being 
compromised). Despite file servers being largely untrusted, it is still an 
issue to provide absolutely no protection against the physical compromise of a 
file server. In the event of a file server machine being compromised in our 
current implementation, an attacker could host a fake file server that would 
act as an already-authenticated file server. This server could then proceed to 
host malicious versions of user files or simply leak the files to other users or 
onto the internet (although we have already protected against this in T6 of 
Phase 4 via the Leslie-Lamport one-time password scheme). 
</p>

<p>
In order to defend against this threat, a mechanism must be developed to protect 
the existence of the file server's private RSA key on disk, so that even if the 
key is physically stolen, it cannot be used by an attacker to host a fake file 
server. This can be achieved through the use of the "starter's" (file server 
administrator's) private key. On the execution of the file server, the starter's 
private RSA key is used to generate a confidentiality and integrity key that 
will be used to encrypt and verify the file server's private RSA key when it is 
loaded from disk. The two keys are <b>k<sub>c</sub></b>, used for encryption, 
and <b>k<sub>i</sub></b> which is used for integrity checks. The keys are 
generated by hashing, using SHA-256, the starter's private RSA key concatenated 
with "confidentiality" and "integrity" respectively. After the file server 
private key is successfully loaded and verified, it is used as normal throughout 
the system as outlined in our previous phases.
</p>

<p>
This mechanism is sufficient for defending against this threat due to the fact 
that the starter of the file server is, or is physically verified by, the system 
administrator. In addition, this administrator is tasked with the responsibility 
of keeping his private RSA key (used to create <b>k<sub>c</sub></b> and 
<b>k<sub>i</sub></b> to protect the file server private RSA key) safe from 
compromise. This means that the key used to protect the file server private key 
is not present on the system outside of the initial starting of the file server, 
and will not be stolen in the result of a machine compromise of any verified 
file server.
</p>

<!-- END CHANGES HERE -->
    </section>

    <section id="threat12">
      <h2>Threat T12: Lack of Plausible Deniability</h2>
<!-- BEGIN CHANGES HERE -->
<p>
This threat is if an adversary (or a malicious server) records client server 
interactions then they can prove that the user took part in this conversation.
</p> 

<p>
In our current system, no communication provides any form of plausible 
deniability to any of the parties involved. This is due primarily to the use of 
signed Diffie-Hellmen to create secure sessions between both the client and the 
group server and the client and the file server. Since the first two messages of 
protocol are signed with the sender's respective private keys, any third party 
can discover the identity of the parties involved by examining message logs of 
any communications throughout our file sharing system. An attacker that has 
compromised any of the parties involved could send sensitive, innapropriate, or 
"illegal" data after authenticating with another party, then effectively 
"blackmail" the original compromised user with message logs "proving" that 
user's supposed misuse of the system, or simply release the message log to the 
internet in an attempt to undermine the validity of the file sharing system.
</p>

<p>
Thankfully, this issue is not terribly complex to design a mechanism to defend 
against. Instead of signing the messages in our Diffie-Hellman protocol (as in 
Phase 4, T5), we will encrypt them with each party's respective public RSA keys. 
In this version of Diffie-Hellman, each party is still sure that only the 
intended recipient could have correctly responded successive messages in the 
protocol due to security properties of public key cryptography. However, a third 
party would not be able to verify that any individual party truly sent any given 
message, as anyone could generate a false message log as the information used in 
each pre-secured message of the protocol utilizes only publicly known
information. By making this change to the Diffie-Hellman protocols used to set 
up secure connections between clients, group servers, and file serevers, we can 
effectively provide all parties involved in communication in our system 
plausible deniability.
</p>

<p>
This mechanism adequately provides plausible deniability to users of our file 
sharing system. Since only an individual has access to their private RSA key and 
they are trusted to keep that key safe, it is acceptable to use them in order to 
verify the indentity of the recipient of messages throughout the various uses of 
the Diffie-Hellman protocol to set up secure communication between two parties. 
Furthermore, all set up for secure communication throughout the system now uses 
only publicly available information, so message logs cannot be used to verify 
message recipients or senders any longer.
</p>

<!-- END CHANGES HERE -->
    </section>    


<!-- END CHANGES HERE -->
    </section>
    <section id="attack">
      <h2>Attacks</h2>
<!-- BEGIN CHANGES HERE -->

<h3>Attack leveraged via Threat 8</h3>
An attacker could simply load up the GroupList and the UserList into their own group server implementation (this is possible because the GroupList and UserList are unencrypted and the implementation of the objects that underlie these lists is known due to transparency of mechanism) and start to change things. They could add a new account and then add that new user to each group. This is dangerous because they could access any sensitive files in the groups they add themselves too. They could even add themselves to the admin group.
<h3>Attack leveraged via Threat 9</h3>
"groupserverprivate.key" is unencrypted on the disk so if a user on that machine were to steal that file they would have the group servers public key. This could be used to create fake tokens. These fake tokens could then be signed with this key which would cause them to be accepted. 
<h3>Attack leveraged via Threat 10</h3> 
Files on the disk for the file server could be modified. This modification would not be detected so any changes could junk the file or worse they could be changed and the changes were not noticed which could lead to non correct information.
<h3>Attack leveraged via Threat 11</h3>
"fileserverprivate.key" is unencrypted on the disk so if a user steals the private key for the file server they can impersonate the file server. This can lead to the clients uploading a sensitive file to the fake server.
<h3>Attack leveraged via Threat 12</h3>
Similar to the attack of the fake file server if a client uploads a suspicious file to one of these fake file servers and the interaction was recorded. This recording would prove that the client was the one who uploaded this file. This is due to the use of signed Diffie-Hellman for log in and authentication.

<p>Write a clear and concise description of the attacks against your
implementation. Describe each step of the attack, and include protocol diagrams
to clarify your discussion as needed. Provide evidence for why these attacks are
possible, and why they represent a threat against your system.</p>

<p>If your group implemented programs to demonstrate your attacks, discuss these
programs here.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="countermeasure">
      <h2>Countermeasures</h2>
<!-- BEGIN CHANGES HERE -->

<p>Write a clear and concise description of the mechanism that your group
proposes to address each attack from the previous section. Follow the format
described in Phases P3 and P4 of the project: describe the mechanism in detail
(including protocol diagrams as needed) and provide justification for why your
proposed mechanism is sufficient for addressing the threat that you have
discovered.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing your threat model and
countermeasure mechanisms. How realistic is your threat model for a real-life
file sharing system? Comment on the design process that your group followed. Did
you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you design attacks that you were unable to
mitigate, or that you think are impossible to mitigate? Use this space to show
off your hard work!</p>

<p>Finally, spend a paragraph discussing the interplay between the
countermeasures for your proposed attacks and your techniques for mitigating
threats T1–T7 from Phases P3 and P4 of the project. Did you have to design your
countermeasures in a particular way so as not to re-introduce these older
threats?</p>

<p>If your group implemented the countermeasures or did any extra credit, please
discuss these additional contributions in this section, as well.</p>

<h3>Extra stuff</h3>
- DDoS, write a program that does this. <br>
- Group name collisions that I discuss in the TODO.

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

